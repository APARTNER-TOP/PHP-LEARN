<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Функції в PHP</title>
   <link rel="stylesheet" href="assets/css/style.css">
</head>

<body>
   <div class="post-content">
      <h2>Функції в PHP</h2>
      У PHP існують безліч вбудованих функцій, які використовуються для найрізноманітніших завдань. Але крім них,
      розробники можуть створювати власні функції користувача, які є фрагментами програми призначених для реалізації
      певних дій, виконання яких досягається викликом функції в необхідному місці програми. Функції можуть приймати
      кілька аргументів та повертати отримане значення, але основне призначення функцій є виключення дублюючих
      фрагментів коду та їх повторне використання.<br><a data-fancybox="gallery" href="assets/img/funcii-v-php.jpg">
         <img src="assets/img/funcii-v-php.jpg" alt="Функції в PHP" title="Функції в PHP" />
      </a>
      <h2>Оголошення та виклик функції</h2>Для оголошення функції необхідно скористатися ключовим словом
      <i>Function</i>, після якого слідує ім’я функції, у круглих дужках параметри та у фігурних дужках тіло:
      <pre><code>function myFunction()<br>{<br>    // Оператори<br>}<br></code></pre>
      <div class="notice">Стандарт кодування <i>PSR</i> рекомендує ім’я функції задавати в camelCase-стилі з першою
         малою літерою, щоб відрізняти функції від класів.</div>Функція може повертати значення. Для цього необхідно
      використовувати конструкцію <i>return</i>:
      <pre><code>function myFunction()<br>{<br>    // Оператори<br>    return 0;<br>}</code></pre>Продемонструємо
      приклад, де функція обчислює суму двох чисел:
      <pre><code>&lt;?php<br>function getSum()<br>{<br>    $sum = 1 + 2;<br>    return $sum;<br>}<br>echo getSum(); // 3</code></pre>
      У цьому прикладі функція не приймає жодного аргументу, а просто обчислює суму та повертає отриманий результат.
      Після цього вона викликається у тілі конструкції <i>Echo</i> для виведення результату у браузер. Можна змінити
      функцію так, щоб вивід здійснювався виключно в тілі функції, для цього необхідно змінити конструкцію <i>return</i>
      на <i>echo</i>. Однак такий підхід зазвичай не вітається, тобто сильно звужує область застосування функції,
      оскільки рядок, що повертається, неможливо буде передати далі для обробки іншим функціям.<br><br>Функція може
      викликатись до її оголошення, за винятком тих випадків, якщо оголошення функції здійснюється залежно від умови
      усередині фігурних дужок. У цьому випадку спроба виклику функції, оголошеної раніше оголошення функції призводить
      до помилки: "<i>Fatal error: Uncaught Error: Call to undefined function</i>".<h2>Параметри та аргументи функції
      </h2>Використовуючи параметри функції можна значно збільшити її гнучкість:
      <pre><code>&lt;?php<br>function getSum($a, $b)<br>{<br>    $sum = $a + $b;<br>    return $sum;<br>}<br>echo getSum(1, 2); // 3</code></pre>
      Змінні <i>$a</i> та <i>$b</i>, які задаються у круглих дужках під час оголошення, називаються параметрами функції.
      При виклику функції замість них можуть бути підставлені змінні з іншими назвами або просто значення, які
      називаються аргументами. Як аргументи можуть виступати висловлювання і навіть інші функції.<h2>Типи параметрів та
         значення результату виконання</h2>Дозволяється при оголошенні функції вказувати типи параметрів. Якщо необхідно
      задати тип значення результату виконання, він вказується через двокрапку безпосередньо перед тілом функції:
      <pre><code>&lt;?php<br>function getSum(int $a, int $b) : int<br>{<br>    return $a + $b;<br>}<br>echo getSum(1, 2); // 3<br>echo getSum(1.5, 2.5); // 3</code></pre>
      <h2>Передача параметрів за значенням та посиланням</h2>За замовчуванням параметри функції змінюються лише
      всередині функції і ці зміни не впливають на значення змінних за межами функції.
      <pre><code>&lt;?php<br>function getSum($var) // аргумент передається за значенням<br>{<br>    $var = $var + 5;<br>    return $var;<br>}<br>$new_var = 10;<br>echo getSum($new_var); // 15<br>echo $new_var; // 10</code></pre>
      Для того, щоб змінні, передані функції, зберігали своє значення при виході з неї, застосовується передача
      параметрів за посиланням. Для цього перед ім’ям змінної необхідно помістити амперсанд (&amp;):
      <pre><code>function get_sum(&amp;$var)</code></pre>Об’єкти та масиви передаються у функцію за посиланням, тому
      стосовно таких параметрів можна не застосовувати символ амперсанда (&amp;).
      <pre><code>&lt;?php<br>function getSum(&amp;$var) // аргумент передається за значенням<br>{<br>    $var = $var + 5;<br>    return $var;<br>}<br>$new_var = 10;<br>echo getSum($new_var); // 15<br>echo $new_var; // 15</code></pre>
      <h2>Необов’язкові параметри</h2>Якщо налаштувати параметри за замовчуванням, то вони не є необов’язковими.
      <pre><code>&lt;?php<br>function getSum($a = 1, $b = 2)<br>{<br>    $sum = $a + $b;<br>    return $sum;<br>}<br>echo getSum(); // 3<br>echo getSum(2); // 4<br>echo getSum(2, 3); // 5</code></pre>
      З прикладу видно, що навіть якщо функції <i>getSum()</i> не передаються аргументи, вона успішно здійснює
      обчислення за участю параметрів за замовчуванням. Якщо функція містить безліч обов’язкових і необов’язкових
      параметрів, всі обов’язкові параметри слід розташовувати до необов’язкових, інакше буде виведена помилка:
      "<i>Fatal error: Uncaught ArgumentCountError: Too few arguments to function</i>".<h2>Змінна кількість параметрів
      </h2>Щоб створити функцію, яка приймає змінну кількість аргументів, перед останнім параметром слід вказати
      трикрапку. Усередині функції такий параметр розглядається як масив, що містить усі додаткові параметри:
      <pre><code>&lt;?php<br>function echoList(...$items)<br>{<br>    foreach ($items as $value) {<br>        echo $value; // выводим элемент<br>    }<br>}<br>echoList('red', 'green', 'yellow'); // red green yellow</code></pre>
      До версії 5.6 РНР не підтримував описуваний механізм обробки змінної кількості параметрів. Натомість
      використовувалися функції <a href="https://www.php.net/manual/en/function.func-num-args"
         target="_blank">Func_num_args</a>, <a href="https://www.php.net/manual/en/function.func-get-arg"
         target="_blank">Func_get_arg</a> та <a href="https://www.php.net/manual/en/function.func-get-args"
         target="_blank">Func_get_args</a>.<br><br>Оператор <i>...</i> може використовуватися не тільки перед
      аргументами функцій, але й при виклику з масивом. Це дозволяє здійснити «розгортання» масиву:
      <pre><code>&lt;?php<br>function tooManyArgs($a, $b, $c)<br>{<br>    echo "Перший параметр: $a";<br>    echo "Другий параметр: $b";<br>    echo "Третій параметр: $c";<br>}<br>$items = ['red', 'yellow', 'green'];<br>tooManyArgs(...$items);</code></pre>
      Як видно з прикладу, можна помістити значення параметрів у масив <i>$items</i> і передати його функції,
      випередивши оператором <i>...</i>, який розгорне елементи масиву у відповідні параметри:
      <pre><code>Перший параметр: red<br>Другий параметр: yellow<br>Третій параметр: green</code></pre>
      <h2>Глобальні змінні</h2>Змінні функції мають локальну область видимості. Це означає, що навіть якщо локальна
      (всередині функції) і зовнішня (поза функцією) змінні мають однакові імена, то локальна змінна ніяк не вплине на
      зовнішню змінну. Локальну змінну можна зробити зовнішньою, якщо перед ім’ям вказати ключове слово <i>global</i>. У
      цьому випадку зміни як усередині функції, так і поза нею впливатимуть на змінну, а сама змінна називатиметься
      глобальною. Якщо локальна змінна оголошена як <i>global</i>, то до неї можливий доступ із будь-якої частини
      програми:
      <pre><code>&lt;?php<br>function getSum()<br>{<br>    global $a;<br>    $a = 1; // Змінюємо глобальну змінну<br>    return $a;<br>}<br>$a = 5;<br>echo $a;       // виводить 5<br>echo getSum(); // виводить 1 (глобальна змінна змінена)<br>echo $a;       // виводить 1</code></pre>
      <h2>Статичні змінні</h2>Оскільки локальні змінні мають своєю областю видимості функцію, час життя локальної
      змінної визначається часом виконання функції, у якій вона оголошена. Це означає, що у різних функціях абсолютно
      незалежно друг від друга можна використовувати змінні з однаковими іменами. Локальна змінна при кожному виклик
      функції ініціалізується заново, тому функція-лічильник завжди буде повертати значення 1:
      <pre><code>&lt;?php<br>function counter()<br>{<br>    $counter = 0;<br>    return ++$counter;<br>}</code></pre>Для
      того, щоб локальна змінна зберігала своє попереднє значення при нових викликах функції, її можна оголосити
      статичною за допомогою ключового слова <i>static</i>:
      <pre><code>&lt;?php<br>function counter()<br>{<br>    static $counter = 0;<br>    return ++$counter;<br>}</code></pre>
      У прикладі, змінна <i>$counter</i> встановлюється в нуль за першого виклику функції, і при наступних викликах
      функція запам’ятає, яким було значення змінної при попередніх викликах.<br><br>Часом життя статичних та глобальних
      змінних є час виконання сценарію. Тобто, якщо користувач перезавантажує сторінку, що призводить до нового
      виконання сценарію, змінна <i>$counter</i> ініціалізується заново.<h2>Повернення масиву функцією</h2>Якщо передати
      конструкції <i>return</i> масив, то функція поверне масив як значення. Більш того, такий масив може створюватись
      динамічно за допомогою конструкції <i>array()</i> або <i>[]</i>. До цього прийому вдаються щоразу, коли функція
      повинна повернути кілька значень, а передача значень по посиланню не допускається. Продемонструємо приклад, в
      якому функція приймає як значення розмір файлу в байтах і повертає масив, перший елемент якого містить розмір в
      байтах, другий - в кілобайтах, третій - в мегабайтах, а четвертий - в гігабайтах.
      <pre><code>&lt;?php<br>function formatSize($bytes)<br>{<br>    $kbytes = $bytes / 1024;<br>    $mbytes = $kbytes / 1024;<br>    $gbytes = $mbytes / 1024;<br>    return [$bytes, $kbytes, $mbytes, $gbytes];<br>}<br>list($bytes, $kbytes, $mbytes, $gbytes) = formatSize(45678921);</code></pre>
      Якщо масив має постійну невелику кількість елементів, то оперувати їм у скрипті не завжди зручно. Тому часто при
      виклик функції елементи масиву відразу ж зіставляються змінним за допомогою конструкції <a
         href="https://www.php.net/manual/en/function.list" target="_blank">List</a>, що продемонстровано в попередньому
      прикладі.<h2>Рекурсивні функції</h2>Рекурсія – це виклик функцією самої себе. Наведемо приклад рекурсивної
      функції:
      <pre><code>&lt;?php<br>function callself($counter)<br>{<br>    if ($counter &gt; 0) {<br>        echo $counter--;<br>        callself($counter);<br>    }<br>    else return;<br>}<br>callself(5);</code></pre>
      Результатом роботи функції буде послідовність цифр: 54321. Функція викликає саму себе доти, доки її параметр
      <i>$counter</i> додатній і не дорівнює нулю. Оскільки рекурсивні функції відносяться до важких для сприйняття
      конструкцій мови, їх по можливості намагаються уникати. Небезпека використання неналагоджених рекурсивних функцій
      полягає у можливості їхнього зависання, тобто переходу в режим нескінченної рекурсії.<br><br>Майже в будь-якому
      випадку можна уникнути рекурсивних функцій. Винятком є ​​завдання, так чи інакше пов’язані з обходом дерев. До
      таких завдань відноситься, наприклад, видалення каталогів, коли число файлів і підкаталогів заздалегідь невідоме,
      і необхідно викликати функцію видалення доти, доки не будуть видалені файли на найглибшому рівні
      вкладеності.<br><br>У РНР можна оголошувати функції всередині іншої функції. На відміну від звичайних функцій,
      вкладена функція не може використовуватися доти, доки не буде здійснено виклик основної функції.<h2>Динамічне ім’я
         функції</h2>За аналогією зі змінними, ім’я функції може бути динамічним і зберігатись у рядковій змінній -
      передача такої змінної оператором круглих дужок (з параметрами, якщо вони потрібні) призводить до виклику функції:
      <pre><code>&lt;?php<br>function str()<br>{<br>    return 'Hello, World!';<br>}<br>$var = 'str';<br>echo $var(); // Hello, World!</code></pre>
      <h2>Анонімні функції</h2>Анонімні функції – це функції без імені:
      <pre><code>&lt;?php<br>$echoList = function (...$str)<br>{<br>    foreach ($str as $value) {<br>        echo $value;<br>    }<br>};<br>// Виклик функції<br>$echoList('red', 'yellow', 'green'); // red yellow green</code></pre>
      <h2>Замикання</h2>Замикання – це функція, яка запам’ятовує стан оточення у момент свого створення. Навіть якщо
      стан змінюється, замикання містить початковий стан. Для активізації необхідно використовувати ключове слово
      <i>use</i>, а за ним у дужках можна вказати змінні, які мають увійти до замикання:
      <pre><code>&lt;?php<br>$message = 'First';<br>$check = function(array $errors) use ($message)<br>{<br>    if (isset($errors) &amp;&amp; count($errors) &gt; 0) {<br>        echo $message;<br>        foreach($errors as $error) {<br>            echo $error;<br>        }<br>    }<br>};<br>$check([]); // First<br>$erorrs[] = 'Second';<br>$check($erorrs); <br>$message = 'Third';<br>$erorrs = ['Fourth', 'Fifth', 'Sixth'];<br>$check($erorrs);</code></pre>
      У прикладі створюється анонімна функція-замикання, яка міститься в змінній <i>$check</i>, за допомогою ключового
      слова <i>use</i> замикання захоплює змінну $message, яку використовує у своїй роботі. Спроба змінити значення
      змінної пізніше не призводить до результату. Замикання «пам’ятає» стан змінної на момент свого створення.
      Результатом виконання скрипта будуть наступні рядки:
      <pre><code>First<br>Second<br>First<br>Fourth<br>Fifth<br>Sixth</code></pre>Основне призначення замикань – заміна
      глобальних змінних. На відміну від глобальних змінних, ви можете передати в середину функції значення, але вже не
      зможете змінити змінну, передану через механізм замикання. Найголовніше – жодні зміни глобальної змінної в інших
      частинах програми не зможуть вплинути на значення, передане через замикання.<br><br>
   </div>

   <div class="task">
      <br>
      Завдання:<br>
      1) Пройтись по виченому матеріалові і спробувати зробити на практиці. <br>
      2) Оголошення та виклик функції,
      Передати параметри та аргументи функції,
      Типи параметрів та значення
      результату виконання, Передача параметрів за значенням та посиланням, Необов’язкові параметри, Змінна кількість
      параметрів, Глобальні змінні, Статичні змінні, Повернення масиву функцією, Рекурсивні функції, Динамічне ім’я
      функції, Анонімні функції, Замикання.
      <br>
      <br>
   </div>

</body>

</html>