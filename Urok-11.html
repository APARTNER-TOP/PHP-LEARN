<!DOCTYPE html>
<html lang="uk">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Завантаження файлів методом POST</title>
   <link rel="stylesheet" href="assets/css/style.css">

   <!-- hightlight -->
   <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">

   <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
   <!-- and it's easy to individually load additional languages -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js"></script>

   <style>
      .hljs {
         display: block;
         overflow-x: auto;
         padding: 0.5em;
         background: #002b36;
         color: #839496;
      }
   </style>
</head>

<body>
   <div class="post-content">
      <h1>Завантаження файлів методом POST</h1>

      <p>Ця можливість дозволяє завантажувати як текстові, так і бінарні файли. За допомогою PHP-функцій автентифікації
         та роботи з файлами ви маєте повний контроль над тим, кому дозволено завантажувати файли та що робити з файлом
         після завантаження.</p>

      <p>PHP може отримувати завантажені файли з будь-якого браузера, сумісного зі стандартом RFC-1867.</p>

      <h2>Налаштування параметрів PHP</h2>

      <p>Існує кілька параметрів конфігурації PHP, які потрібно попередньо перевірити для успішного завантаження файлів.
         У цьому розділі ми розглянемо всі параметри, які є важливими для завантаження файлів PHP. Ці параметри можна
         настроїти у файлі php.ini.</p>

      <pre>
         <code class="hljs">
            < ?php 
               echo php_ini_loaded_file(); 
            ?>
         </code>
      </pre>

      <p>Ось виведення з установчого файлу з деякими корисними значеннями за замовчуванням.</p>

      <pre>
         <code class="hljs">
            ;  Чи  дозволяти  завантаження файлів HTTP . _   
            file_uploads  =  ON
            ;  Тимчасовий  каталог  для  завантажених файлів HTTP  . 
            ;  Буде  використано  системне  значення за умовчанням  , якщо  не  встановлено .
            ; upload_tmp_dir  = 
            ;  Максимально  дозволений  розмір  завантажуваних  файлів . _ 
            upload_max_filesize  =  16M
            ;  Максимальна  кількість  файлів  ,  які  можна  завантажити  за допомогою одного запиту _    
            max_file_uploads  =  20
            ;  Максимальний  розмір  даних  POST  , які приймає PHP . _    
            post_max_size  =  20M
            max_input_time  =  60
            memory_limit  =  128M
            max_execution_time  =  30
         </code>
      </pre>

      <h2>Ключові настройки</h2>
      <h3>file_uploads</h3>
      <p>Значення директив file_uploadsмає бути встановлено на On, щоб дозволити завантаження файлів. Значення за
         умовчанням для цієї директиви - On.</p>

      <h3>upload_max_filesize</h3>
      <p>Директива upload_max_filesizeдозволяє вам створити максимальний розмір завантаженого файлу. За умовчанням він
         встановлений в 2M(два мегабайта), і ви можете переопределити цей параметр, використовуючи файл .htaccess . Два
         мегабайти не дуже відповідають сьогоднішнім стандартам, тому вам, можливо, доведеться це збільшити. Якщо ви
         отримаєте повідомлення про помилку - file exceeds upload_max_filesize при спробі завантажити файл, вам
         необхідно збільшити це значення. Якщо ви це зробите, обов'язково увеличьте post_max_size(см. нижче).</p>

      <h3>upload_tmp_dir</h3>
      <p>Встановлює тимчасовий каталог, який буде використовуватися для зберігання завантажених файлів. У більшості
         випадків вам не потрібно заспокоюватися про цю настройку. Якщо ви не встановите його, буде використовуватися
         системний тимчасовий каталог за замовчуванням.</p>

      <h3>post_max_size</h3>
      <p>Директива post_max_sizeдозволяє налаштувати максимальний розмір даних POST. Якщо файли завантажуються за
         допомогою POST-запитів, це значення має бути більше, ніж зазначено в директиві upload_max_filesize. Наприклад,
         якщо ваш upload_max_filesizeфайл становить 16M(16 мегабайт), вам потрібно встановити post_max_sizeв 20M.</p>

      <h3>max_file_uploads</h3>
      <p>Це дозволяє вам встановити максимальну кількість файлів, які можуть бути завантажені за раз. За замовчуванням
         20розумна кількість.</p>

      <h3>max_input_time</h3>
      <p>Це максимальна кількість секунд, цей скрипт дозволено аналізувати дані входу. Ви повинні встановити його на
         розумне значення, якщо ви маєте справу з великими завантаженнями файлів. 60(60 секунд) є хорошим показником для
         більшості програм.</p>

      <h3>memory_limit</h3>
      <p>Директива memory_limitвказує максимальний об'єм пам'яті, який може потребувати скрипт. Якщо ви стикаєтеся з
         проблемами при завантаженні великих файлів, вам необхідно переконатися, що значення цієї директиви більше, ніж
         зазначено в директиві post_max_size. Значення за замовчуванням - 128M(128 мегабайт), тому, якщо у вас немає
         дуже великих post_max_sizeі upload_max_filesize, вам не потрібно заспокоюватися про це.</p>

      <h3>max_execution_time</h3>
      <p>Це максимальна кількість секунд, дозволена для роботи скрипта. Якщо ви стикаєтеся з проблемами при завантаженні
         більших файлів, ви можете переглянути можливість збільшення цього значення. 30(30 секунд) повинні добре
         працювати для більшості програм.</p>

      <h2>Створення форми HTML</h2>

      <pre>
         <code>
            < ?php
               session_start (); 
            ?>
            < !DOCTYPE html>
            < html>
            < head>
            < title> Завантаження файлу PHP < /title>
            < /head>
            < body>
            <?php
               if  ( isset ( $_SESSION [ 'повідомлення' ])  &&  $_SESSION [ 'повідомлення' ])
               {
                  printf ( '< b>%s< /b>' ,  $_SESSION [ 'повідомлення' ]);
                  не встановлено ( $_SESSION [ 'повідомлення' ]);
               }
            ?>
            < form  method= "POST"  action= "upload.php"  enctype= "multipart/form-data" >
               < div>
                  < span> Завантажте файл: < /span>
                  < input  type= "file"  name= "uploadedFile"  />
               < /div>
               < input  type= "submit"  name= "uploadBtn"  value= "Upload"  />
            < /form>
            < /body>
            < /html>
         </code>
      </pre>

      <p>Хоча це може показати типову форму PHP, існує важлива відмінність у значенні атрибута enctypeтега
      <form>. Він повинен бути встановлений у multipart/form-data, так як форма містить поле файлу.</p>

         <p>Атрибут enctypeвказує на тип кодування, який має відповідати при виправленні форми, і приймає одне з
            наступних трьох значень:</p>
         <p>application/x-www-form-urlencoded: Це значення за умовчанням, коли ви не встановлюєте значення атрибута
            enctypeявно. У цьому випадку символи кодуються перед відправкою на сервері. Якщо у вас немає поля файлу у
            вашій формі, ви повинні використовувати це значення для атрибута enctype.</p>
         <p>multipart/form-data: Коли ви використовуєте значення multipart/form-dataдля атрибута enctype, воно дозволяє
            завантажити файли за допомогою методу POST. Крім того, він гарантує, що символи не кодуються при відповіді
            форми.</p>
         <p>text/plain: Зазвичай це не використовується. За допомогою цієї настройки дані відправляються без кодування.
         </p>

         <p>Потім ми виводимо поле файлу, який дозволяє вам вибрати файл з вашого комп'ютера.</p>

         <pre>
            <code>
               < input  type= "file"  name= "uploadedFile"  />
            </code>
         </pre>

         <p>Крім того, ми відобразили повідомлення у верхній частині форми. Це повідомлення відображає статус
            завантаження файлу, і воно буде встановлено в змінній сесії скриптом upload.php . Ми розглядаємо це в
            наступному розділі.</p>

         <pre>
            <code>
               < ?php
                  if (isset($_SESSION['message']) && $_SESSION['message'])
                  {
                     printf('< b>%s< /b>', $_SESSION['message']);
                     unset($_SESSION['message']);
                  }
               ?>
            </code>
         </pre>

         <h2>Логіка завантаження</h2>
         <p>У файлі upload.php ми перевірили, чи дійсно це дійсний запит POST.</p>

         <pre>
            <code>
               if  ( isset ( $_POST [ 'uploadBtn' ])  &&  $_POST [ 'uploadBtn' ]  ==  'Upload' )  {
                  ...
               }
            </code>
         </pre>

         <p>У PHP, коли файл завантажується, суперглобальна змінна $_FILESзаповнюється вся інформація про завантажений
            файл. Вона ініціалізується як масив і може містити наступну інформацію для успішного завантаження файлу.</p>

         <h3>Про глобальну змінну $_FILES</h3>
         <p>$_FILES – елемент, який успішно використовується для поставленого спочатку завдання. Розібравшись із ним,
            можна успішно перевірити факт завантаження файлу на сервер сайту.</p>

         <p>$_FILES – глобальна змінна PHP, яка нагадує $_POST та $_GET. Це – асоціативний масив, в якому міститься
            інформація про завантажений документ. Для цього застосовується метод HTTP POST.</p>

         <p>Якщо в процесі виконати print_r($_FILES), під час обробки раніше запропонованого шаблону буде виведено таку
            інформацію:</p>

         <pre>
            <code>
               Array
               (
                  [inputfile] => Array
                     (
                           [name] => upload-file-php.jpg
                           [type] => image/jpeg
                           [tmp_name] => /Applications/XAMPP/xamppfiles/temp/phpcQiYhh
                           [error] => 0
                           [size] => 6887
                     )
               )
            </code>
         </pre>

         <p>$_FILES['userfile']['name']
            Оригінальна назва файлу на комп'ютері клієнта.</p>

         <p>$_FILES['userfile']['type']
            Mime-тип файлу, якщо браузер надав таку інформацію. Як приклад можна навести "image/gif". Цей mime-тип не
            перевіряється на стороні PHP, тому не покладайтеся на його значення без перевірки.</p>

         <p>$_FILES['userfile']['size']
            Розмір у байтах прийнятого файлу.</p>

         <p>$_FILES['userfile']['tmp_name']
            Тимчасове ім'я, з яким файл було збережено на сервері.</p>

         <p>$_FILES['userfile']['error']
            Код помилки , яка може виникнути під час завантаження файлу.</p>

         <p>$_FILES['userfile']['full_path']
            Повний шлях представлений браузером. Це значення не завжди містить реальну структуру каталогів, і йому не
            можна довіряти. Доступно з PHP 8.1.0.</p>


         <p>Перевірка на errors – важливий момент усієї операції. Якщо під час заливання файлу на сервер виникли
            неполадки, документ може не з'явитися на сайті. Ось кілька найпоширеніших «збоїв», які можуть бути виведені
            на екран:</p>

         <ol>
            <li>Upload_err_form_size (значення 2) – розмір документа перевищує встановлене змінної форми max_file_size
               значення.</li>
            <li>Ini_size (значення 1) – розмір більший, ніж передбачає змінна upload_max_filesize у php.imi.</li>
            <li>Err_ok (значення 0) – успішне завантаження файлу. Помилок у процесі не виявлено.</li>
            <li>_partial (значення 3) – неповне завантаження файлу.</li>
            <li>No_file (значення 4) – документ для завантаження на сервер відсутній.</li>
            <li>No_tmp_dir (значення 6) – зазначеної директорії для тимчасового зберігання файлу не виявлено.</li>
            <li>Cant_write (значення 7) – записати файл на диск неможливо.</li>
         </ol>


         <p>Якщо завантаження файлу пройшла успішно, ми ініціалізуємо кілька змінних з інформацією про завантажений
            файл.</p>

         <pre>
            <code>
               // отримати деталі завантаженого файлу 
               $fileTmpPath  =  $_FILES [ 'uploadedFile' ][ 'tmp_name' ];
               $fileName  =  $_FILES [ 'uploadedFile' ][ 'name' ];
               $fileSize  =  $_FILES [ 'uploadedFile' ][ 'size' ];
               $fileType  =  $_FILES [ 'uploadedFile' ][ 'type' ];
               $fileNameCmps  =  explode ( "." ,  $fileName );
               $fileExtension  =  strtolower ( end ( $fileNameCmps ));
            </code>
         </pre>

         <p>У наведеному вище коді ми також вияснили розширення завантаженого файлу та зберегли його в змінній
            $fileExtension.</p>

         <p>Оскільки завантажений файл може містити позначки та інші спеціальні символи, краще очистити ім’я файлу, і це
            саме те, що ми зробили в наступному кроці.</p>

         <pre>
            <code>
               $newFileName = md5(time() . $fileName) . '.' . $fileExtension;
            </code>
         </pre>

         <p>Важливо, щоб ви обмежили тип файлу, який може бути завантажений на певне розширення, і не дозволили всі. Ми
            це зробили, перевіривши розширення завантаженого файлу за допомогою набору розширень, який ми хочемо
            дозволити для завантаження.</p>

         <pre>
            <code>
               $allowedfileExtensions = array('jpg', 'gif', 'png', 'zip', 'txt', 'xls', 'doc');
               if (in_array($fileExtension, $allowedfileExtensions)) {
               ...
               }
            </code>
         </pre>

         <p>Нарешті, ми використовуємо функцію move_uploaded_fileдля переміщення завантаженого файлу у визначене місце
            за нашим вибором.</p>

         <pre>
            <code>
               // directory in which the uploaded file will be moved 
               $uploadFileDir = './uploaded_files/';
               $dest_path = $uploadFileDir . $newFileName;
               if(move_uploaded_file($fileTmpPath, $dest_path))
               {
                  $message ='File is successfully uploaded.';
               }
               else
               {
                  $message = 'There was some error moving the file to upload directory. Please make sure the upload directory is writable by web server.';
               }
            </code>
         </pre>

         <p>Функція move_uploaded_fileприймає два аргумента. Першим аргументом є ім'я завантаженого файлу, а другим
            аргументом - шлях призначення, в якому ви хочете перемістити файл.</p>

         <p>Накінець, ми перенаправляємо користувача у файл index.php . Крім того, ми встановлюємо відповідне
            повідомлення в змінній сесії, яке буде показано користувачам після перенаправлення у файлі index.php .</p>

         <h3>Мультизавантаження</h3>
         <p>PHP-скрипти дозволяють здійснювати мультизавантаження. Її можна реалізувати кількома способами:</p>

         <ol>
            <li>Через ім'я файлу input. Відповідні «назви» мають бути різними.</li>
            <li>Залучаючи масив. У цій ситуації input можуть мати ті самі імена.</li>
         </ol>

         <p>Все залежить від особистих уподобань розробника. Перший варіант дає змогу завантажувати кілька документів
            через елементи введення. Якщо створюється та чи інша кількість елементів input, у $_FILES створюються певні
            «ключові» компоненти. Ось наочний приклад:</p>

         <pre>
            <code>
               < input type="file" name="logo" />
               < input type="file" name="banner" />
            </code>
         </pre>

         <p>$_FILES виглядатиме масивом:</p>

         <pre>
            <code>
               Array
               (
                  [logo] => Array
                     (
                           [name] => upload-file-php.jpg
                           [type] => image/jpeg
                           [tmp_name] => /Applications/XAMPP/xamppfiles/temp/phpcQiYhh
                           [error] => 0
                           [size] => 6887
                     )
                  [banner] => Array
                  (
                        [name] => banner-file-php.jpg
                        [type] => image/jpeg
                        [tmp_name] => /Applications/XAMPP/xamppfiles/temp/phpcQiYhh
                        [error] => 0
                        [size] => 6887
                  )
               )
            </code>
         </pre>

         <p>А тепер варто розглянути другий варіант – з одним полем input, але з масивами. Для uploaded file PHP можна
            використовувати масив з input type, прописаним в php:</p>

         <pre>
            <code>
               < input type="file" name="pic[]" />
               < input type="file" name="pic[]" />
               < input type="file" name="pic[]" />
            </code>
         </pre>

         Для раніше розглянутого HTML $_Files матиме таку структуру:

         <pre>
            <code>
               Array
               (
                  [pic] => Array
                     (
                        [name] => Array(
                           [0] => upload-file-php1.jpg
                           [1] => upload-file-php2.jpg
                           [2] => upload-file-php3.jpg
                        )
                        [type] => Array(
                           [0] => upload-file-php1.jpg
                           [1] => upload-file-php2.jpg
                           [2] => upload-file-php3.jpg
                        )
                        [tmp_name] => Array(
                           [0] => /Applications/XAMPP/xamppfiles/temp/
                           [1] => /Applications/XAMPP/xamppfiles/temp/
                           [2] => /Applications/XAMPP/xamppfiles/temp/
                        )
                        [error] => Array(
                           [0] => 0
                           [1] => 0
                           [2] => 0
                        )
                        [size] => Array(
                           [0] => 3500
                           [1] => 5887
                           [2] => 2239
                        )
                     )
               )
            </code>
         </pre>

         <h3>Коди, розглянуті на прикладі – це шаблони. Вони готові до роботи, хоч і примітивні.</h3>

         <p>Для нормального
            функціонування вони потребують розширення:</p>
         <p>видалення символів та прогалин з назви;</p>
         <p>занесення інформації до БД для подальшої обробки;</p>
         <p>перевірки розміру файлів;</p>
         <p>стиснення зображень та картинок.</p>

   </div>

   <div class="task">
      <br>
      Завдання:<br>
      1) Повторити пройдений матеріал<br>

      2) Зробити можливість
      завантаження файлів першим способом. Відправляти усі дані на сторінку form_data.php , використовувати тип передачі
      пост. На сторінці form_data виловити усі файли і відобразити їх. Якщо файлу не буде надіслано то
      повернутися на попередню сторінку й відобразити текст під полем
      де завантаження файлу , що файл обовязково має бути надісланий. Також перевірити чи це було надіслано
      зображення.<br>

      3) Зробити можливість
      завантаження файлів другим способом. Відправляти усі дані на сторінку form_data.php , використовувати тип передачі
      пост. На сторінці form_data виловити усі файли і відобразити їх. Якщо файлу не буде надіслано то
      повернутися на попередню сторінку й відобразити текст під полем
      де завантаження файлу , що файл обовязково має бути надісланий. Також перевірити чи це було надіслано зображення.
      <br>
      <br>
   </div>

   <script>hljs.highlightAll();</script>
</body>

</html>