<!DOCTYPE html>
<html lang="uk">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Масиви в PHP</title>
   <link rel="stylesheet" href="assets/css/style.css">
</head>

<body>
   <div class="post-content">
      Найбільш часто серед усіх структур зберігання даних зустрічаються масиви, які є індексованими сукупностями
      змінних
      одного типу. Кожна змінна або елемент масиву має свій індекс та пронумеровані від 0 до N - 1, де N - розмір
      масиву.
      Імена масивів, як і змінних, починаються з символу <i>$</i>. Для звернення до окремих елементів масиву необхідно
      розмістити після його імені квадратні дужки [], в яких вказати індекс елемента масиву. Якщо елементом масиву
      виступає інший масив, то такий масив називають багатовимірним, а для звернення до кінцевих елементів
      використовують
      кілька пар квадратних дужок, де вказуються індекси відповідно двох масивів.<br>
      <a data-fancybox="gallery"
         href="assets/img/masuvu-v-php.jpg">
         <img src="assets/img/masuvu-v-php.jpg" alt="Масиви в PHP" />
      </a>
      <h2>Створення масиву</h2>Для створення масивів є кілька способів. Найпростішим є використання конструкції
      <i>Array</i>, у круглих дужках якої через кому перераховуються елементи масиву. Конструкція <i>array()</i> як
      результат повертає масив.
      <pre><code>&lt;?php<br>$arr = array('red', 'green', 'yellow');<br>echo $arr[0]; // red<br>echo $arr[1]; // green<br>echo $arr[2]; // yellow<br>echo $arr;    // Notice: Array to string conversion (array)</code></pre>
      У цьому прикладі створюється масив <i>$arr</i>, що складається з трьох елементів, пронумерованих від 0 до 2.
      Кожен
      елемент масиву виводиться окремою конструкцією <a href="https://www.php.net/manual/en/function.echo"
         target="_blank">Echo</a>. При спробі виводу всього масиву <i>$arr</i> у вікно браузера замість його вмісту
      буде
      виведений рядок «<i>Array</i>» із попередженням типу <i>Notice</i>. Для перегляду структури та вмісту масиву
      передбачено спеціальну функцію <a href="https://www.php.net/manual/en/function.print-r"
         target="_blank">Print_r</a>.<br><br>Створити масив можна за допомогою квадратних дужок. Наступний приклад
      еквівалентний попередньому:
      <pre><code>&lt;?php<br>$arr = ['red', 'green', 'yellow'];</code></pre>Цей підхід повторює синтаксис масивів в
      інших
      сучасних мовах скриптів, таких як <i>Python</i> або <i>Ruby</i>. Однак, оскільки історично конструкція
      <i>array()</i> з’явилася в PHP першою, дуже часто в коді готових РНР-додатків можна зустріти саме її.<br><br>Як
      видно з попередніх прикладів, елементам масиву автоматично призначені індекси, починаючи з нульового. Однак
      індекс
      початкового елемента, а також порядок слідування індексів можна змінювати. Для цього в конструкції
      <i>array()</i>
      або <i>[]</i> перед елементом вказується його індекс за допомогою оператора <i>=&gt;</i>:
      <pre><code>&lt;?php<br>$arr = [5 =&gt; 'red', 'green', 'yellow'];</code></pre>В результаті першому елементу
      масиву
      <i>$arr</i> призначається індекс 5, наступні елементи автоматично отримують номери 6 та 7. Також слід зазначити,
      що
      елементи з індексами 0, 1, ... 4 та 8, ... просто не існують, звернення до них сприймається як звернення до
      неініціалізованої змінної зі значенням <i>Null</i>.<br><br>Призначати індекси можна як першому елементу, так і
      усім
      наступним елементам масиву. Усі непронумеровані елементи автоматично отримуватимуть значення, що дорівнює
      максимальному та збільшеному на одиницю.<br><br>Ще одним способом створення масиву є присвоєння
      неініціалізованим
      елементам масиву нових значень. Наступний приклад повністю еквівалентний попередньому:
      <pre><code>&lt;?php<br>$arr[5] = 'red';<br>$arr[] = 'green';<br>$arr[] = 'yellow';</code></pre>Якщо значення
      індексу
      не вказується у квадратних дужках, призначення індексів до елементів відбувається автоматично.<br><br>Ще один
      спосіб
      створення масиву полягає у приведенні скалярної змінної (тобто змінної типу <a
         href="blogs/9373" target="_blank">Integer</a>, <a
         href="blogs/9391"
         target="_blank">Float</a>, <a href="blogs/9445" target="_blank">String</a> або <a
         href="blogs/9368" target="_blank">Boolean</a>) до типу <a
         href="blogs/9527" target="_blank">Array</a>. В результаті буде створено масив, що
      містить
      один елемент з індексом 0 і значенням, що дорівнює значенню змінної.
      <pre><code>&lt;?php<br>$var = 'color red';<br>$arr = (array)$var;</code></pre>
      <h2>Індексні та асоціативні масиви</h2>Якщо індексами масиву виступають числа, він називається <i>індексним</i>.
      Але
      якщо індексами є рядки, то такий масив називають <i>асоціативним</i>, а його індекси – ключами. Один масив може
      мати
      як числові індекси так і рядкові ключі, і називається змішаним.
      <pre><code>&lt;?php<br>$arr = ['one' =&gt; 'red', 'two' =&gt; 'green'];</code></pre>Результат виконання прикладу
      буде масив:
      <pre><code>Array<br>(<br>    [one] =&gt; red<br>    [two] =&gt; green<br>)</code></pre>При зверненні до
      елементів
      асоціативного масиву замість індексів зазначаються відповідні ключі, які, як і звичайні рядки, залежать від
      регістру.<br><br>Також, крім конструкцій <i>array()</i> та <i>[]</i>, допускається створення елементів
      асоціативного
      масиву за допомогою прямого звернення до них:
      <pre><code>&lt;?php<br>$arr['one'] = 'red';<br>$arr['two'] = 'green';</code></pre>При спробі створення двох
      елементів масиву з однаковими ключами створюється один елемент з останнім значенням.<h2>Багатовимірні масиви
      </h2>
      Якщо елементами масиву виступають інші масиви, тоді масив називається <i>багатовимірним</i>. Принцип створення
      багатовимірних масивів аналогічний до створення одномірних. Масиви можна створювати, звертаючись до елементів
      або
      використовуючи вкладені конструкції <i>array()</i> або <i>[]</i>.
      <pre><code>&lt;?php<br>$arr = [<br>    'color' =&gt; ['red', 'green', 'yellow']<br>];</code></pre>Внаслідок
      такої
      ініціалізації буде створено масив наступної структури:
      <pre><code>Array<br>(<br>    [color] =&gt; Array<br>        (<br>            [0] =&gt; red<br>            [1] =&gt; green<br>            [2] =&gt; yellow<br>        )<br><br>)</code></pre>
      Отриманий масив є змішаним, тобто у ньому присутні як індекси, так і ключі асоціативного масиву.<h2>Інтерполяція
         елементів масиву в рядки</h2>У рядках з подвійними лапками замість змінних підставляється їхнє значення. Так
      само поводяться елементи масиву:
      <pre><code>&lt;?php<br>$arr[] = 'red';<br>echo "Color $arr[0]";</code></pre>Якщо йдеться про асоціативні масиви,
      то
      лапки, якими обрамляється ключ, вказувати не слід, інакше скрипт поверне помилку аналізу:
      <pre><code>Parse error: syntax error, unexpected '' (T_ENCAPSED_AND_WHITESPACE), expecting '-' or identifier (T_STRING) or variable (T_VARIABLE) or number (T_NUM_STRING) </code></pre>
      Однак, у разі багатовимірних масивів інтерполювати елемент так, як це продемонстровано у попередньому прикладі,
      вже
      не вдасться. Для інтерполяції потрібно або укласти елемент у фігурні лапки <i>{}</i>, або використовувати
      конкатенацію рядків.
      <pre><code>&lt;?php<br>$arr[] = 'red';<br>echo "Color {$arr['0']}";<br>echo "Color ".$arr[0];</code></pre>Як
      видно з
      прикладу, при використанні фігурних дужок до ключів елементів асоціативних масивів можна вказувати лапки.<h2>
         Конструкція List</h2>За допомогою конструкції <a href="https://www.php.net/manual/en/function.list"
         target="_blank">List</a> можна здійснити обернену задачу конструкцій <i>array()</i> і <i>[]</i> - перетворити
      елементи масиву на звичайні змінні:
      <pre><code>&lt;?php<br>$arr = [1, 2, 3];<br>list($one, $two, $three) = $arr;<br>echo $one;   // 1<br>echo $two;   // 2<br>echo $three; // 3</code></pre>
      Конструкція <i>list()</i> працює виключно з числовими масивами, нумерація індексів яких починається з нуля. При
      спробі перетворення елементів асоціативного масиву будуть виведені попередження типу: <i>Notice: Undefined
         offset</i>.<br><br>У круглих дужках конструкції <i>list()</i> кількість елементів може не збігатися з
      кількістю
      елементів вихідного масиву. При цьому, якщо елементів у масиві більше – зайві будуть відкинуті, якщо менше –
      частина
      змінних залишиться неініціалізованими. Крім того, частина перших елементів масиву може бути пропущена, для цього
      достатньо вказати відповідну кількість ком:
      <pre><code>&lt;?php<br>$arr = [1, 2, 3];<br>list(,,$three) = $arr;<br>echo $one;   // Notice: Undefined variable<br>echo $two;   // Notice: Undefined variable<br>echo $three; // 3</code></pre>
      Конструкцію <i>list()</i> можна використовувати для обміну значень змінних без змінної-посередника:
      <pre><code>list($y, $x) = [$x, $y];</code></pre>
      <h2>Обхід масиву</h2>Дуже часто необхідно здійснити обхід масиву в циклі. Для цього можна скористатися
      операторами
      <i>For</i> або <i>While</i>, для асоціативних масивів призначений спеціалізований оператор <i>Foreach</i>.
      Продемонструємо обхід індексного масиву за допомогою циклу <i>For</i>:
      <pre><code>&lt;?php<br>$numbers = ['1', '2', '3'];<br>for ($i = 0; $i &lt; count($numbers); $i++) {<br>    echo $numbers[$i];<br>}</code></pre>
      Результатом роботи прикладу буде рядок: 123. За допомогою функції <a
         href="https://www.php.net/manual/en/function.count" target="_blank">Count</a> виконали підрахунок кількості
      елементів у масиві, яка приймає як параметр масив і повертає кількість елементів у ньому.<br><br>Цикл
      <i>Foreach</i>
      спеціально створений для асоціативних масивів і має наступний синтаксис:
      <pre><code>foreach ($array as [$key =&gt;] $value) {<br>    оператори; <br>}</code></pre>Цикл <i>Foreach</i>
      послідовно обходить всі елементи масиву <i>$array</i>, поміщаючи при кожній ітерації циклу ключ у змінну
      <i>$key</i>, а значення у змінну <i>$value</i>. Імена цих змінних можуть бути будь-якими.
      <pre><code>&lt;?php<br>$arr = [<br>    'first'  =&gt; '1',<br>    'second' =&gt; '2',<br>    'third'  =&gt; '3'<br>];<br>foreach ($arr as $index =&gt; $val) {<br>    echo $index . ' = '. $val;<br>}</code></pre>
      Результатом роботи прикладу будуть наступні рядки:
      <pre><code>first = 1<br>second = 2<br>third = 3</code></pre>Змінну <i>$index</i> можна опустити, оскільки вона
      не є
      обов’язковою.<br><br>Число вкладених циклів відповідає розмірності масиву:
      <pre><code>&lt;?php<br>$arr = [<br>    'Color' =&gt; ['red', 'yellow', 'green'],<br>];<br>foreach ($arr as $name =&gt; $color) {<br>    echo '&lt;p&gt;'.$name.'&lt;/p&gt;';<br>    foreach ($color as $value) {<br>        echo '&lt;p&gt; -'.$value.'&lt;/p&gt;';<br>    }<br>}</code></pre>
      Результат виконання скрипту:
      <pre><code>Color<br>-red<br>-yellow<br>-green</code></pre>
      <h2>Злиття масивів</h2>Для складання значення двох масивів можна використовувати оператор плюс (+).
      <pre><code>&lt;?php<br>$fst = [1 =&gt; 'one'];<br>$snd = [2 =&gt; 'two'];<br>$sum = $fst + $snd;</code></pre>В
      результаті виконання прикладу буде виведено наступний масив <i>$sum</i>:
      <pre><code>Array<br>(<br>    [1] =&gt; one<br>    [2] =&gt; two<br>)</code></pre>При додаванні масивів з
      однаковими
      індексами, у результуючий масив потрапляють елементи з першого масиву:
      <pre><code>&lt;?php<br>$fst = [1, 2];<br>$snd = [3, 4, 5];<br>$sum = $fst + $snd;</code></pre>В результаті
      виконання
      прикладу буде виведено наступний масив <i>$sum</i>:
      <pre><code>Array<br>(<br>    [0] =&gt; 1<br>    [1] =&gt; 2<br>    [2] =&gt; 5<br>)</code></pre>Якщо необхідно,
      щоб
      в результуючий масив потрапили елементи обох масивів, замість оператора <i>+</i> використовують спеціальну
      функцію
      <a href="https://www.php.net/manual/en/function.array-merge" target="_blank">Array_merge</a>, яка в якості
      параметрів приймає масиви, що зливаються.
      <pre><code>&lt;?php<br>$fst = [1, 2];<br>$snd = [3, 4, 5];<br>$sum = array_merge($fst, $snd);</code></pre>В
      результаті виконання прикладу буде виведено наступний масив <i>$sum</i>:
      <pre><code>Array<br>(<br>    [0] =&gt; 1<br>    [1] =&gt; 2<br>    [2] =&gt; 3<br>    [3] =&gt; 4<br>    [4] =&gt; 5<br>)</code></pre>
      <h2>Порівняння масивів</h2>Порівнювати масиви можна з допомогою операторів рівності <i>==</i> і нерівності
      <i>!=</i>. Два масиви вважаються рівними, якщо кількість та значення їх ключів збігаються:
      <pre><code>&lt;?php<br>$ar1 = [1, 2];<br>$ar2 = [1, 2];<br>$ar3 = [1, 2, 3];<br>if ($ar1 == $ar2) {<br>    echo 'Масиви рівні';<br>} else {<br>    echo 'Масиви не рівні';<br>}<br>if ($ar1 == $ar3) {<br>    echo 'Масиви рівні';<br>} else {<br>    echo 'Масиви не рівні';<br>}</code></pre>
      За першої умови буде виведено результат <i>Масиви рівні</i>, за другої - <i>Масиви не
         рівні</i>.<br><br>Оператори
      еквівалентності <i>===</i> та нееквівалентності <i>!==</i> відповідно схожі з операторами рівності <i>==</i> та
      нерівності <i>!=</i>. Два масиви вважаються еквівалентними, якщо збігаються не тільки кількість їх елементів,
      ключі
      та значення, але є і збіг типів значень.<h2>Перевірка існування елементів масиву</h2>Перевірити, чи існує той чи
      інший елемент масиву, можна за допомогою конструкції <a href="https://www.php.net/manual/en/function.isset"
         target="_blank">Isset</a>:
      <pre><code>&lt;?php<br>$arr = [1, 2];<br>for ($i = 0; $i &lt; 3; $i++) {<br>    echo isset($arr[$i]) ? "Елемент \$arr[$i] існує" : "Елемент \$arr[$i] не існує";<br>}</code></pre>
      Як результат прикладу будуть наступні рядки:
      <pre><code>Елемент $arr[0] існує<br>Елемент $arr[1] існує<br>Елемент $arr[2] не існує</code></pre>Існування
      масиву
      може бути перевірено за допомогою конструкції <i>Isset</i>. Якщо необхідно переконатися, чи поточна змінна
      належить
      до типу масиву, використовують функцію <a href="https://www.php.net/manual/en/function.is-array"
         target="_blank">Is_array</a>.<br><br>Для пошуку значень у масиві використовується функція <a
         href="https://www.php.net/manual/en/function.in-array" target="_blank">In_array</a>, яка здійснює пошук
      значення
      в масиві та повертає <i>True</i>, якщо значення знайдено, і <i>False</i> – інакше.
      <pre><code>&lt;?php<br>$arr = [1, 2];<br>if (in_array(2, $arr)) {<br>    echo "Елемент існує";<br>}</code></pre>
      Аналогічно функції <i>In_array</i> для пошуку заданого ключа масиві можна скористатися функцією <a
         href="https://www.php.net/manual/en/function.array-key-exists" target="_blank">Array_key_exists</a>, яка
      повертає
      <i>True</i>, якщо ключ знайдений в масиві.<br><br>Знайти ключ масиву за значенням дозволяє функція <a
         href="https://www.php.net/manual/en/function.array-search" target="_blank">Array_search</a>, яка шукає
      значення
      масиву і, якщо значення знайдено, повертає відповідний ключ, інакше повертається <i>False</i>.<br><br>
   </div>

   <div class="task">
      <br>
      Завдання:<br>
      1) створити усі види масививів і спробувати отримати дані з нього по ключу індексу. <br>
      2) Спробувати злиття масивів, конструкцію List, обхід масиву, порівняння масивів, перевірка існування елементів
      масиву
      <br>
      <br>
   </div>

</body>

</html>