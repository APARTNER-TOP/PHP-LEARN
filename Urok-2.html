<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Змінні і типи даних в PHP</title>
   <link rel="stylesheet" href="assets/css/style.css">
</head>

<body>
   <div class="post-content">
      Змінні є головним об’єктом практично будь-якої мови програмування. У загальному розумінні під терміном змінна
      розуміється іменована область пам’яті, в якій може зберігатися рядок, число, або складний об’єкт. Операції зі
      змінними здійснюються за допомогою їх імен.<br><a data-fancybox="gallery"
         href="assets/img/php-zminni-i-tupu-danuh.jpg">
         <img src="assets/img/php-zminni-i-tupu-danuh.jpg" alt="Змінні і типи даних в PHP">
      </a>
      <h2>Оголошення змінної</h2>У мові програмування РНР всі змінні починаються зі знака долара (<i>$</i>), за яким
      може бути будь-яка кількість букв, цифр і символів підкреслення. Слід також зауважити, що перший символ не може
      бути цифрою, а імена змінних чутливі до регістру.
      <pre><code>$color = "Жовтий";<br>$Color = "Зелений";<br><br>echo $color; // Жовтий<br>echo $Color; // Зелений</code></pre>
      Ініціалізувати змінну і привласнити їй значення можна за допомогою оператора присвоювання "<i>=</i>". Також
      допускається ініціалізація одним значенням відразу декільком змінних за рахунок того, що оператор присвоювання
      повертає результат присвоєння. наприклад:
      <pre><code>$color = $Color = "Жовтий";<br>echo $color; // Жовтий<br>echo $Color; // Жовтий</code></pre>
      <h2>Типи даних</h2>На відміну від більшості інших мов програмування, типізація даних РНР є доволі слабкою, що в
      свою чергу дозволяє не вимагати суворого визначення типу змінних при їх оголошенні. У ході виконання програми тип
      змінної може бути змінений неявним чином без спеціальних перетворень, що дозволяє розробнику практично не
      замислюватися про типи даних.<br><br>Також зустрічаються і псевдотипи - умовні позначення одного або декількох
      типів. В основному вони використовуються спільно з функціями і методами. Наприклад, <i>mixed</i> - будь-який тип,
      <i>number</i> - може зберігати значення типу <i>integer</i> або <i>double</i>. Ключове слово <i>void</i> означає
      відсутність змінної. Кілька типів можуть бути розділені вертикальною лінією, що аналогічно логічній операції
      «або». Наприклад, псевдотип <i>number</i> можна записати, використовуючи наступну послідовність базових типів:
      <i>integer | double</i>.<h2>Основні типи даних, які підтримуються РНР:</h2><strong>Integer</strong>. Ціле число,
      максимальне значення якого залежить від розрядності операційної системи. У разі 32-бітної операційної системи
      число може приймати значення від -2 147 483 648 до 2 147 483 647. Якщо розрядність становить 64 біта, діапазон
      можливих значень від -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807.<br><br><strong>Double</strong> |
      <strong>Float</strong>. Дійсне число, мінімально можливе значення якого становить від ± 2.23х10-308 ступеня до ±
      1.79х10308.<br><br><strong>Boolean</strong>. Логічний тип, здатний приймати лише два значення: <i>True</i>
      (істинне) і <i>False</i> (хибне).<br><br><strong>String</strong>. Строковий тип. Може зберігати рядок,
      максимальний розмір якого становить 2 Гбайт.<div class="notice">У 32-бітних системах і PHP версій менше 7, рядки
         не можуть бути більшими за 2 Гб (2147483647 байт). У PHP 7.0.0, на 64-бітних платформах немає будь-яких
         досяжних обмежень для довжини рядка.</div><strong>Array</strong>. Масив. Це об’єднання декількох змінних під
      одним ім’ям, звертання до яких відбувається за допомогою індексу масиву.<br><br><strong>Object</strong>. Об’єкт.
      Це конструкція, яка об’єднує кілька різнотипних змінних і методи їх обробки.<br><br><strong>Resource</strong>.
      Дескриптор, що дозволяє оперувати тим чи інших ресурсом, доступ до якого здійснюється за допомогою бібліотечних
      функцій. Дескриптори застосовуються при роботі з файлами, базами даних, динамічними зображеннями
      тощо.<br><br><strong>Null</strong>. Спеціальний тип, який сигналізує про те, що змінна не була
      ініціалізована.<br><br><strong>Callable</strong> | <strong>Callback</strong>. Деякі функції РНР можуть приймати в
      якості аргументів інші функції, які називаються функціями зворотного виклику. Змінні даного типу містять посилання
      на такі функції.<h2>Цілі числа</h2>Оскільки більшість прикладних задач носить виключно арифметичний характер,
      найбільш поширеними в програмуванні є цілі числа. Крім того, операції з ними виконуються найшвидше.<br><br>Важливо
      також враховувати той факт, що в мові програмування PHP не буває переповнення - виходу значення за допустимі межі.
      Наприклад, якщо отримане значення не міститься в <i>Integer</i>, для нього автоматично вибирається більший тип
      даних <i>Float</i>:
      <pre><code>var_dump(9223372036854775807);    // int(9223372036854775807)<br>var_dump(9223372036854775808);    // float(9.223372036854776E+18)</code></pre>
      Оголошення цілочисельних змінних може здійснюватися кількома способами:
      <pre><code>$num = 123;     // десяткове число<br>$num = +123;    // десяткове число<br>$num = -123;    // від’ємне число<br>$num = 012;     // вісімкове число (еквівалентно 10)<br>$num = 0xA;     // шістнадцяткове число (еквівалентно 10)</code></pre>
      Додатне ціле число оголошується без вказівки перед ним знака плюс. Для оголошення від’ємного числа необхідно перед
      ним вказати символ мінуса. За замовчуванням числа задаються в десятковій системі числення, однак в РНР можна
      оголошувати змінні в вісімковій і шістнадцятковій системах числення.

      <!-- Більш докладно про цілі числа і системи
      числення можна дізнатися зі статті <a href="https://kovelpost.com/blogs/9373" target="_blank">Типи даних в PHP:
         Цілі числа</a>. -->

      <h2>Дійсні числа (числа з плаваючою крапкою)</h2>Дійсні числа (Float чи Double) мають дуже
      великий інтервал, вийти який практично неможливо. Існують дві форми запису дійсного числа: стандартна та
      експоненційна.<br><br>При виведенні числа з плаваючою крапкою відводиться 12 символів, це значення може бути
      змінено за допомогою директиви <i>Precision</i> у конфігураційному файлі <i>php.ini</i>.<br><br>Оголошення дійсних
      чисел:
      <pre><code>&lt;?php<br>// Стандартний запис<br>$var = 1.23456;<br>// Експонентний запис<br>$var = 1.23456E2; // 123.456</code></pre>

      <!-- Докладніше про дійсні числа можна дізнатися зі статті <a href="/blogs/9391"
         target="_blank">Числа з плаваючою крапкою (Float)</a> -->

      .<h2>Логічний тип</h2>Змінні логічного типу
      <strong>Boolean</strong> приймають лише два значення: <strong>True</strong> (істина) або <strong>False</strong>
      (брехня). Константи <i>True</i> і <i>False</i> не залежать від регістру, але за стандартами написання коду
      <i>PSR-2</i>, рекомендується писати малими літерами: <i>true</i> і <i>false</i>. Найчастіше змінні логічного типу
      застосовуються разом із операторами порівняння і циклу.

      <!-- Докладніше про логічний тип можна дізнатися із статті <a
         href="https://kovelpost.com/blogs/9368" target="_blank">Двійкові числа (boolean)</a>. -->

      <h2>Рядки</h2>Рядки
      призначені для зберігання текстової інформації. Як зазначалося вище, у 32-бітних системах і PHP версій менше 7,
      рядки не можуть бути більшими за 2 Гб (2147483647 байт). У PHP 7.0.0, на 64-бітних платформах немає будь-яких
      досяжних обмежень для довжини рядка. На максимальний об’єм рядка також впливає обмеження об’єму пам’яті, що
      відводиться під РНР-скрипт. Обсяг пам’яті визначається директивою <i>Memory_limit</i> конфігураційного файлу
      <i>php.ini</i>. Оголошення рядків здійснюється за допомогою лапок:
      <pre><code>&lt;?php<br>$str = "Hello, World!";</code></pre>
      <h2>Лапки</h2>Рядки та рядкові змінні створюються шляхом укладання тієї чи іншої фрази в лапки. У РНР є можливість
      використовувати кілька типів лапок, кожен вид яких має власні особливості.<br><br>Подвійні лапки ("...")
      дозволяють замість змінних РНР підставляти їх значення. Така підстановка називається інтерполяцією.
      <pre><code>&lt;?php<br>$str = "Hello, world!";<br>echo "Значення змінної - $str"; // Значення змінної – Hello, world!</code></pre>
      Одиночні лапки ('...') не дозволяють підставляти значення змінних.<br><br>Значення, укладене у зворотні лапки
      (`...`), сприймається як системна команда. Замість такої системної команди повертається результат виконання
      команди:
      <pre><code>&lt;?php<br>echo `dir`;<br><br>// Volume in drive C has no label.<br>// Volume Serial Number is FE44-B92A<br><br>// Directory of C:\localhost\mysite<br><br>// 30.05.2019  15:47    &lt;DIR&gt;          .<br>// 30.05.2019  15:47    &lt;DIR&gt;          ..<br>// 23.05.2019  12:27            13 753 .htaccess<br>// 31.05.2019  15:11             1 083 index.php</code></pre>
      У мовах програмування, зазвичай, підтримуються два варіанти лапок: одинарні і подвійні, щоб при необхідності
      застосовувати одинарні лапки для обрамлення подвійних, а подвійні - для обрамлення одинарних.

      <!-- Більш детально можна
      дізнатися зі статті <a href="https://kovelpost.com/blogs/9277" target="_blank">Різниця між подвійними та
         одинарними лапками у PHP</a>. -->

      <pre><code>&lt;?php<br>echo "Змінна набуває значення 'abc'";<br>echo 'Самовчитель "PHP"';</code></pre>Іноді під
      час використання подвійних лапок необхідно придушити підстановку значень змінної. Для цього застосовується
      екранування символу <i>$</i> зворотним слешем <i>\</i>.
      <pre><code>&lt;?php<br>$str = "Hello, world!";<br>echo "Значення змінної - \$str"; // Значення змінної - $str</code></pre>
      Аналогічно екранування застосовується і для розміщення подвійних лапок у рядку, обрамленому подвійними
      лапками.<br><br>Застосування зворотного слеша з іншими символами інтерпретується особливим чином. Найчастіше
      використовуються символи переводу рядка (<i>\n</i>), повернення каретки (<i>\r</i>), символ табуляції (<i>\t</i>),
      зворотний слеш (<i>\\</i>), подвійна (<i>\"</i>) та одинарна лапка (<i>\'</i>). Розміщення змінних та спеціальних
      символів (за винятком <i>\'</i>) в одинарних лапках не призводить до їхньої спеціальної
      інтерпретації.<br><br>Хорошим тоном є вказівка ​​меж змінної всередині рядка обрамленням фігурними дужками
      ({...}):
      <pre><code>&lt;?php<br>$str = "Hello, world!";<br>echo "Значення змінної - {$str}"; // Значення змінної - Hello, world!</code></pre>
      <h2>Оператор &lt;&lt;&lt;</h2>Оголосити рядок можна також за допомогою оператора <i>&lt;&lt;&lt;</i>, який ще
      називають вбудованим документом (hеrе-документ). Відразу після цієї послідовності розміщується мітка, кінець
      оператора позначається повторним входженням мітки. Мітка залежить від регістру, але зазвичай вводиться за
      допомогою великих букв.
      <pre><code>&lt;?php<br>$str = &lt;&lt;&lt; EOT<br>Доки не зустрінеться<br>мітка, можна писати все що завгодно<br>EOT;<br>echo $str;</code></pre>
      Після першої мітки EOT не повинно бути пробілів, лише перевод рядка, як, втім, і перед останньою міткою EOT.
      Послідовність &lt;&lt;&lt; зазвичай застосовують для введення об’ємного тексту, який незручно вводити за допомогою
      традиційних лапок.<br><br>Маркер можна укладати в одинарні лапки, які повідомляють інтерпретатору РНР, що змінні
      всередині такого рядка не інтерполюються.
      <pre><code>&lt;?php<br>$str = "Hello, world!";<br>$str = &lt;&lt;&lt; 'EOT'<br>Доки не зустрінеться<br>мітка, можна писати все що завгодно $str<br>EOT;<br>echo $str;</code></pre>
      Результат виконання:
      <pre><code>Доки не зустрінеться<br>мітка, можна писати все що завгодно $str</code></pre>
      <h2>Неініціалізовані змінні</h2>У мові програмування РНР змінна створюється відразу ж при першому зверненні. Якщо
      вона не була ініціалізована за допомогою оператора присвоєння =, генерується зауваження (Notice):
      <pre><code>&lt;?php<br>echo $city;<br>//  Notice: Undefined variable: city in test.php on line 2</code></pre>В
      результаті звернення до неініціалізованої змінної генерується зауваження про невизначену змінну.<br><br>Крім того,
      чутливість РНР до помилок можна змінити, налаштувавши у конфігураційному файлі <i>php.ini</i> директиву
      <i>Error_reporting</i> або виконавши функцію <i>Error_reporting</i>. Однак не рекомендується використовувати
      придушення повідомлень про помилки при розробці програм, але в готових проектах краще відключати від користувачів
      виведення помилок, а адміністраторам дивитися їх у журналі.<h2>Спеціальний тип Null</h2>Для позначки
      неініціалізованої змінної призначений спеціальний тип <i>Null</i>. Змінна також отримує цей тип, якщо вона
      ініціалізується константою типу <i>Null</i> або знищується за допомогою конструкції <a
         href="https://www.php.net/manual/en/function.unset.php" target="_blank">Unset</a>.<br><br>Константа <i>Null</i>
      залежить від регістру. Однак, необхідно дотримуватися стандарту <i>PSR-2</i> та записувати її у маленькими
      літерами.
      <pre><code>&lt;?php<br>$city = null;</code></pre>Слід зазначити, що з ініціалізації змінної з допомогою константи
      <i>null</i> і подальшому зверненні до змінної у висловлюваннях генерації зауваження "<i>Notice: Undefined
         variable</i>" немає.<h2>Знищення змінної</h2>Для знищення змінної можна користуватися конструкцією <a
         href="https://www.php.net/manual/en/function.unset.php" target="_blank">Unset</a>. У параметрах конструкції
      вказується або одна, або кілька розділених комами змінних, які підлягають знищенню. Після виклику даної
      конструкції пам’ять, виділена під значення змінної, повертається системі, а самій змінній надається значення
      <i>null</i>.
      <pre><code>&lt;?php<br>// Оголошуємо змінну<br>$city = "Kiev";<br>// Знищуємо<br>unset($city);<br>// Спроба звернення до неіснуючої змінної<br>echo $city; // Генерируется "Notice: Undefined variable"</code></pre>
      Знищення непотрібних змінних може бути корисним, коли скрипт оперує об’ємними даними (наприклад, вмістом файлів),
      і їх розмір загрожує перевищити обсяг пам’яті, що виділяється скрипту.<h2>Перевірка існування змінної</h2>Для
      перевірки існування змінної використовується конструкція <a href="https://www.php.net/manual/en/function.isset"
         target="_blank">Isset</a>, в параметрах якої вказується або одна, або кілька розділених комами змінних. На
      відміну від конструкції <i>Unset</i> тут повертається значення логічного типу. Якщо всі змінні існують,
      конструкція повертає <i>True</i>, якщо хоча б одна змінна не існує – повертається <i>False</i>.
      <pre><code>&lt;?php<br>// Оголошуємо порожню змінну<br>$str = '';<br>if (isset($str)) { // true<br>    echo 'Змінна $str існує';<br>}<br>// Позначаємо змінну $str як неініціалізовану<br>$str = null;<br>if (isset($str)) { // false<br>    echo 'Змінна $str існує';<br>}</code></pre>
      Як видно з прикладу, порожній рядок не еквівалентний неініціалізованій змінній. Для перевірки, чи є рядок порожнім
      чи ні, призначена спеціальна конструкція <a href="https://www.php.net/manual/en/function.empty"
         target="_blank">Empty</a>, яка приймає як параметр лише одну змінну і повертає <i>True</i>, якщо змінна
      дорівнює порожньому рядку <i>""</i>, нулю <i>0</i>, символу нуля в рядку "<i>0</i>", <i>null</i>, <i>false</i>,
      порожньому масиву <i>array()</i>, неініціалізованій змінній. У решті випадків повертається <i>False</i>.<h2>
         Визначення типу змінної</h2>PHP дозволяє визначити, якого типу належить змінна. Це корисно, враховуючи, що
      деякі функції (особливо функції для роботи з масивами та об’єктами) вкрай чутливі до типу
      даних.<br><br>Універсальною функцією, що дозволяє визначити тип змінної є функція <a
         href="https://www.php.net/manual/en/function.var-dump" target="_blank">Var_dump</a>, яка виводить інформацію
      про змінну. Значення, що повертається, може приймати одне з значень: "<i>boolean</i>", "<i>integer</i>",
      "<i>double</i>", "<i>string</i>", "<i>array</i>", "<i>object</i>", "<i>resource</i>", "<i>null</i>" і "<i>unknown
         type</i>":
      <pre><code>&lt;?php<br>// Оголошуємо цілу змінну:<br>$number = 123;<br>echo var_dump($number); // int(123)<br><br>// Оголошуємо логічну змінну:<br>$flag = true;<br>echo var_dump($flag); // bool(true)<br><br>// Оголошуємо рядкову змінну:<br>$str = '';<br>echo var_dump($str); // string(0) ""<br><br>// Оголошуємо дійсну змінну:<br>$var = 1.7;<br>echo var_dump($var); // float(1.7) <br><br>// Знищуємо змінну $var:<br>unset($var);<br>echo var_dump($var); // Notice: Undefined variable (null)</code></pre>
      Для кожного з типів призначена функція, що починається з префікса <i>is_</i>, яка повертає <i>True</i>, якщо
      змінна належить заданому типу. Наприклад, функція <a href="https://www.php.net/manual/en/function.is-int"
         target="_blank">Is_int</a> перевіряє, чи є змінна цілого типу <i>Integer</i>:
      <pre><code>&lt;?php<br>// Оголошуємо цілу змінну<br>$number = 12345;<br>if (is_int($number)) { // true<br>    echo 'Змінна $number є цілим числом';<br>}<br>// Оголошуємо рядкову змінну<br>$str = '12345';<br>if (is_int($str)) { // false<br>    echo 'Змінна $str є цілим числом';<br>}</code></pre>
      Результат роботи прикладу є вивід одного рядка, оскільки тільки <i>$number</i> є цілою змінною. Змінна
      <i>$str</i>, незважаючи на те, що містить число, містить рядковий тип, тому функція <i>Is_int</i> повертає для неї
      <i>False</i>.<br><br>На відміну з інших мов програмування, де типи <i>float</i> і <i>double</i> мають різний
      розмір допустимих значень, у РНР з-поміж них немає відмінностей. Функція <i>Var_dump</i> повертає значення
      <i>float</i> для всіх дійсних чисел, незалежно від того, мають вони тип <i>float</i> або <i>double</i>:
      <pre><code>&lt;?php<br>$float = 123.24;<br>var_dump($float); // float(123.24)<br><br>$double = 123.24e307; // float(INF) <br>var_dump($double);</code></pre>
      <h2>Неявне приведення типів</h2>У мовах програмування, яким властивий серйозний підхід до типізації даних, при
      оголошенні змінної слід обов’язково вказувати її тип, інакше програма призведе до помилки. PHP відноситься до
      слабо типізованих мов, тому від програміста не вимагається явна вказівка ​​типу змінної, а спроба використання її
      в контексті, де очікується змінна іншого типу, призведе до спроб автоматичного (неявного) перетворення змінної до
      потрібного типу. Наприклад, якщо рядок містить число і використовується в арифметичному вираженні, то він
      автоматично буде приведений до числового типу:
      <pre><code>&lt;?php<br>$str = '36.6';<br>$number = 1 + $str;<br>echo $number; // 37.6</code></pre>Інтерпретатор
      РНР отримує з початку рядка найбільш повне значення, що відповідає числу. Якщо витягти число з рядка не вдається,
      його значення розглядається як нульове:
      <pre><code>&lt;?php<br>echo '12abc23' + 1; // 12 + 1 = 13<br>echo 1 + 'два'; // 1 + 0 = 1</code></pre>Цей код
      виконається з приміткою "<i>Notice: A non well formed numeric value encountered</i>", яке попереджає, що виявлено
      неправильно сформоване числове значення.<br><br>Аналогічно число автоматично перетворюється на рядок там, де
      очікується рядкова змінна.<br><br>У логічний тип <i>False</i> автоматично приводяться всі значення рівні нулю "0",
      порожній рядок "", рядок, що містить "0", порожні масиви та об’єкти, а також <i>null</i>, решта змінних
      розглядаються як <i>True</i>.
      <pre><code>&lt;?php<br>$int = 0;<br>if ($int) { // false<br>    echo 'Змінна $int розглядається як true';<br>}<br>$str = "Hello, World!";<br>if ($str) { // true<br>    echo 'Змінна $str розглядається як true';<br>}</code></pre>
      При перетворенні логічного типу до рядка, <i>True</i> перетворюється на "<i>1</i>", а <i>False</i> на порожній
      рядок "". Перетворення логічного типу до числа призводить до перетворення <i>True</i> на <i>1</i>, а <i>False</i>
      на <i>0</i>. Тому <i>True</i> завжди виводиться як одиниця, а <i>False</i> як порожній рядок.<h2>Явне приведення
         типів</h2>У РНР можна явно перетворити змінну на один із підтримуваних типів. Одним із варіантів перетворення
      полягає використання круглих дужок. У них вказується тип, до якого якого слід привести змінну.
      <pre><code>&lt;?php<br>$float = 1.23; // float(1.23)<br>$number = (int)$float; // int(1)</code></pre>Наведемо всі
      можливі варіанти використання оператора круглих дужок: (<i>int</i>|<i>integer</i>) – приведення до цілого типу
      <i>int</i>; (<i>bool</i>|<i>boolean</i>) – приведення до логічного типу <i>boolean</i>;
      (<i>float</i>|<i>double</i>|<i>real</i>) - приведення до дійсного типу <i>double</i>; (<i>string</i>) – приведення
      до рядкового типу <i>string</i>; (<i>array</i>) – приведення до масиву; (<i>object</i>) – приведення до
      об’єкта.<br><br>Крім оператора круглих дужок РНР надає ряд спеціальних функцій, що дозволяють здійснити
      перетворення типу змінної. Функція <a href="https://www.php.net/manual/en/function.settype"
         target="_blank">Settype</a> перетворює тип змінної на потрібний. Для цього в параметрах вказується назва
      змінної та новий тип даних, який може приймати одне з наступних значень: "<i>boolean</i>" або "<i>bool</i>",
      "<i>integer</i>" або "<i>int</i>", "<i>float</i>" або "<i>double</i>", "<i>string</i>", "<i>array</i>",
      "<i>object</i>", "<i>null</i>". Функція повертає <i>True</i>, якщо перетворення було успішно здійснено, і
      <i>False</i> інакше.
      <pre><code>&lt;?php<br>// Оголошуємо рядкову змінну<br>$str = '5abc';<br>// Змінюємо рядок на ціле число<br>settype($str, 'integer'); // int(5) </code></pre>
      Функція <i>Settype</i> повертає логічне значення, а не результат перетворення. Насправді, якщо у явному
      перетворенні виникає потреба, набагато зручніше користуватися спеціалізованими функціями: <a
         href="https://www.php.net/manual/en/function.floatval" target="_blank">Floatval</a>, <a
         href="https://www.php.net/manual/en/function.intval" target="_blank">Intval</a> і <a
         href="https://www.php.net/manual/en/function.strval" target="_blank">Strval</a>.<h2>Динамічні змінні</h2>У PHP
      можна створювати змінні довільного типу, для цього необхідно використовувати подвійний символ <i>$$</i>. Іноді
      назву змінної неможливо визначити заздалегідь, і вона має визначатися у міру виконання скрипта. В цьому випадку
      вдаються до динамічних змінних.
      <pre><code>&lt;?php<br>$id_menu = 10;<br>$str = "active$id_menu"; // "active10"<br>$$str = 1; // $active10 = 1;<br>if (isset($active10)) {<br>    echo "Змінна \${$str} існує і дорівнює $active10";<br>}</code></pre>
      Значення змінної, що настає після першого знака <i>$</i>, сприймається як ім’я нової змінної. Якщо рядок
      <i>$str</i> має значення "active10", ім’я нової змінної буде $active10.<br><br>Ще один спосіб створення динамічних
      змінних полягає у використанні функції <a href="https://www.php.net/manual/en/function.eval"
         target="_blank">Eval</a>. Вона приймає як параметр рядок з РНР-кодом і виконує його:
      <pre><code>&lt;?php<br>$str = '$num = "10";<br>    echo $num;';<br>eval($str); // 10</code></pre>В результаті
      виконання скрипта з лістингу у вікно браузера буде виведено число 10. Таким чином, змінна $num, яка визначена в
      рядку $str, доступна не тільки в межах цього рядка, але і після виконання функції <i>Eval</i>.<h2>Посилання на
         змінні</h2>Для створення посилань використовується оператор <i>&amp;</i>:
      <pre><code>&lt;?php<br>$first = 5;<br>$second = &amp;$first;<br>$second = 1;<br>echo $first; // 1</code></pre>Як
      видно з прикладу, якщо перед ім’ям змінної використовувати оператор <i>&amp;</i>, то інша змінна стає посиланням.
      Обидві назви змінних виступають як синоніми.<br><br>
   </div>

   <div class="post-content">
      Константи - це дані, які зберігають своє значення під час усього виконання скрипта. На відміну від змінних,
      значення констант неможливо змінювати під час виконання скрипта та не можуть мати невизначене значення Null.<br><a
         data-fancybox="gallery"
         href="assets/img/php-konstantu.jpg">
         <img src="assets/img/php-konstantu.jpg" alt="Константи PHP">
      </a>
      <h2>Оголошення константи</h2>Константи оголошуються за допомогою функції <a
         href="https://www.php.net/manual/en/function.define" target="_blank">Define</a>, яка приймає першим параметром
      рядок з ім’ям константи, у другому параметрі передається значення константи. Третій необов’язковий параметр
      визначає чутливість константи до регістру - якщо передати значення <i>True</i>, нова константа не залежатиме від
      регістру. У разі успішного створення константи функція <i>Define</i> повертає <i>True</i>, інакше повертається
      значення <i>False</i>.
      <pre><code>define('ACCESS', true);</code></pre>Значенням константи може бути логічне (<a
         href="/blogs/9368" target="_blank">Boolean</a>), ціле (<a
         href="/blogs/9373" target="_blank">Integer</a>), дійсне (<a
         href="/blogs/9391" target="_blank">Float</a>), рядкове (<a
         href="/blogs/9445" target="_blank">String</a>) чи масив (<a
         href="blogs/9527" target="_blank">Array</a>). Константи не можуть отримувати як значення
      об’єкти (Object) та дескриптори (Resource).<div class="notice">Хоча допускається створення імені констант
         довільного регістру, зазвичай вони записуються у верхньому регістрі. Ця традиція пов’язана з тим, що в інших
         мовах програмування високого рівня константи та змінні ніяк не відрізняються одна від одної, тому правила
         гарного тону рекомендують відрізняти змінні та константи іменами у різних регістрах, щоб покращити
         читабельність програми.</div>
      <pre><code>&lt;?php<br>define('NUM', 1);<br>define('STR', 'Hello, world!');<br>echo NUM;  // 1<br>echo STR;  // Hello, world!<br>echo Num;  // Notice: Use of undefined constant Num - assumed 'Num'</code></pre>
      Як видно з прикладу, звертатися до констант можна за їхнім ім’ям, але, на відміну від змінних, вказувати символ
      <i>$</i> перед ім’ям константи не потрібно. Якщо робиться спроба звернутися до неіснуючої константи - генерується
      зауваження "<i>Notice: Use of undefined constant</i>".<br><br>Слід зазначити, що РНР має низку наперед визначених
      констант: <i>Null</i>, <i>True</i> і <i>False</i>. Всі вони не залежать від регістру, тому в програмах можна
      зустріти різні записи, але стандарт кодування PSR вимагає, щоб вони вказувалися в нижньому регістрі.<br><br>При
      спробі перевизначити вже існуючу константу функція <i>Define</i> повертає значення <i>False</i> і буде виведено
      зауваження "<i>Notice: Constant Name already defined</i>". Після визначення константи змінити її ім’я неможливо.
      <h2>Перевірка існування константи</h2>Перевірити наявність константи можна за допомогою оператора <i>If</i> та
      функції <i>Define</i>. Якщо константа існує, то функція поверне <i>True</i>. Однак цей варіант не дуже зручний,
      тому що створює константу, якщо вона не існує, і виводить зауваження, якщо константа вже визначена. Для перевірки
      існування константи існує окрема функція <a href="https://www.php.net/manual/en/function.defined"
         target="_blank">Defined</a>, єдиним параметром якої є рядок з ім’ям константи. Повертає <i>True</i>, якщо
      константа існує, інакше повертається <i>False</i>:
      <pre><code>&lt;?php<br>// Визначаємо константу<br>define('COLOR', 'red');<br>// Якщо константа існує, виводимо її значення<br>if (defined('COLOR')) echo COLOR; // red</code></pre>
      <h2>Динамічне ім’я константи</h2>За допомогою конструкції <i>$$</i> можна отримати динамічні імена змінних, для
      динамічного формування констант спеціальний синтаксис не передбачено, однак існує окрема функція <a
         href="https://www.php.net/manual/en/function.constant" target="_blank">Constant</a>, яка приймає рядок з ім’ям
      константи та повертає її значення. Якщо константа з такою назвою не виявлена, повертається <i>False</i> і
      виводиться попередження "<i>Warning: constant(): Couldn't find constant</i>".
      <pre><code>&lt;?php<br>define("COLOR", 'red');<br>echo COLOR;<br>echo constant("COLOR");</code></pre>У цьому
      прикладі обидва рядки, що виводять значення константи <i>COLOR</i> за допомогою прямого звернення та функції
      <i>Constant</i> - еквівалентні.<h2>Зумовлені константи</h2>У PHP існує низка наперед визначених констант, значення
      яких виставляє інтерпретатор РНР: <i>__LINE__</i> - поточний рядок у файлі; <i>__FILE__</i> - повний шлях та ім’я
      поточного файлу; <i>__FUNCTION__</i> - ім’я функції; <i>__CLASS__</i> – ім’я класу; <i>__METHOD__</i> - ім’я
      методу; <i>__DIR__</i> - поточний каталог, у якому розташований скрипт; <i>PHP_VERSION</i> – версія інтерпретатора
      PHP; <i>PHP_EOL</i> – символ кінця рядка.<br><br>Крім представлених вище констант, існує безліч зумовлених
      констант, оголошених у різних розширеннях. Привести їх повний список неможливо, крім того, їх набір залежить від
      підключених розширень і може змінюватися. У будь-якому випадку отримати повний список доступних констант можна за
      допомогою функції <a href="https://www.php.net/manual/en/function.get-defined-constants"
         target="_blank">Get_defined_constants</a>.

      <h2>Абсолютний та відносний шлях до файлу</h2>При підключенні до
      скрипту файлів слід вказати шлях до них. Розрізняють відносні та абсолютні шляхи від кореня
      диска.<br><br>Використання відносних шляхів не залежить від сервера розміщення чи робочої станції, де ведеться
      розробка. Проєкт може бути розміщений у будь-якому каталозі, без необхідності переписати шляхи включення. Щоб
      підключити файли при використанні відносних шляхів, необхідно виконувати операції підняття або опускання на один
      або кілька рівнів вище або нижче поточної директорії. Батьківський каталог позначається двома крапками "<i>..</i>"
      і записуються так:
      <pre><code>require_once '../classes/images.php';<br>require_once '../data/config.php';</code></pre>Чим більше
      рівнів вкладень, тим складнішими і довгими стають відносні шляхи, і тим кращі абсолютні шляхи, для яких не
      потрібно обчислювати рівень вкладення щодо поточного файлу.<br><br>У сучасних РНР-додатках для вирішення цієї
      проблеми застосовують кілька прийомів. По-перше, намагаються використовувати одну точку входу, розташовану в
      корені проєкту. При цьому замість вказівки абсолютного шляху використовують наперед визначену константу
      <i>__DIR__</i>, що визначає поточний каталог скрипта.
      <pre><code>require_once __DIR__ .'/classes/images.php';<br>require_once __DIR__ .'/data/config.php';</code></pre>


      <h2>Константи класу</h2>Класи також можуть містити константи, які визначаються ключовим словом <i>Const</i>. Слід
      звернути увагу на те, що ключове слово <i>Const</i> використовується тільки в класах, для оголошення констант поза
      класами призначена функція <i>Define</i>.
      <pre><code>class ConstantClass<br>{<br>    const STR = "Hello, world.";<br>}</code></pre>Так само як і у випадку
      зі статичними членами класів, до констант не можна звертатися за допомогою оператора "-&gt;". Для звертання
      використання оператор дозволу області видимості "<i>::</i>". Існування констант можна перевірити з допомогою
      функції <i>Defined</i>, яка повертає <i>True</i>, якщо константа існує, інакше - <i>False</i>.
      <pre><code>if (defined('ClassConstant::STR')) {<br>    echo 'Константа визначена'; // true<br>}</code></pre>
   </div>

   <div class="task">
      <br>
      Завдання<br>
      1) Оголосити змінні (integer, float, bolean, string, array, object, null) Перевірити їх тип і спробувати змінити
      їх
      тип.<br>
      2) Створити зміну з EOT і вивести значення її.
      Також повторити те , що було на уроці.<br>
      3) Оголошення константи, Перевірка існування, зробити динамічне ім’я константи, Зумовлені константи, Константи
      класу
      <br>
      <br>
   </div>

</body>

</html>