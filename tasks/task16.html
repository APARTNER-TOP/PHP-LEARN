Задача 1:

Написати використання функції error_reporting з використанням усіх константних і бітових значень. Спробувати встановити
в цих типах php.ini,.Htaccess, ini_set ().

Задача 2:

Напишіть програму, яка буде виводити на екран повідомлення про помилки, що виникають в процесі виконання. Для цього
встановіть параметр "display_errors" у значення "On". Після цього спробуйте виконати деякі операції, які призведуть до
виникнення помилок, і переконайтеся, що повідомлення про них відображаються на екрані.

Задача 3:

Напишіть програму, яка буде записувати повідомлення про помилки у файл. Для цього встановіть параметр "log_errors" у
значення "On", а також встановіть параметр "error_log" у ім'я файлу, в який потрібно записувати повідомлення про
помилки. Після цього спробуйте виконати деякі операції, які призведуть до виникнення помилок, і переконайтеся, що
повідомлення про них записуються у файл.

Задача 4:

Напишіть програму, яка буде виводити на екран повідомлення про помилки, які виникають у процесі виконання, але при цьому
не зупинятиметься через помилки. Для цього використайте оператор відключення помилок "@" перед операцією, що може
призвести до помилки. Переконайтеся, що програма продовжує виконуватися, незважаючи на помилки.

Задача 5:

Напишіть програму, яка буде записувати повідомлення про помилки у файл, але при цьому не зупинятиметься через помилки.
Для цього використайте оператор відключення помилок "@" перед операцією, що може призвести до помилки, а також
встановіть параметр "log_errors" у значення "On", а параметр "error_log" - у ім'я файлу, в який потрібно записувати
повідомлення про помилки.

Задача 6:

Напишіть програму, яка буде перехоплювати помилки за допомогою функції set_error_handler(), яка дозволяє зареєструвати
свій обробник помилок. У цій програмі створіть свій власний обробник помилок, який буде виводити повідомлення про
помилки на екран.

Задача 7:

Напишіть програму, яка буде перехоплювати помилки за допомогою функції set_exception_handler(), яка дозволяє
зареєструвати свій обробник винятків. У цій програмі створіть свій власний обробник винятків, який буде виводити
повідомлення про винятки на екран.

Задача 8:

Напишіть програму, яка буде використовувати функцію set_error_handler() для перехоплення помилок. Створіть свій власний
обробник помилок, який буде виводити повідомлення про помилки на екран

Задача 9:

Створіть програму, яка використовує функцію set_error_handler() для перехоплення помилок. В програмі має бути
функція-обробник помилок, яка буде виводити повідомлення про помилки на екран.

Потім в програмі має бути фрагмент коду, який буде використовувати функцію restore_error_handler() для відновлення
стандартного обробника помилок PHP після того, як наш власний обробник був зареєстрований.

Задача 10:

Створіть програму, яка буде генерувати помилки за допомогою функції trigger_error(). В програмі має бути фрагмент коду,
який буде перехоплювати ці помилки за допомогою функції-обробника помилок.

Задача 11:

Створіть програму, яка демонструє використання функції debug_backtrace(). В програмі має бути фрагмент коду, який
викликає функцію-обробник помилок, який використовує debug_backtrace() для відстеження викликів функцій, що призвели до
помилки.

Задача 12:

Напишіть програму, яка перевірятиме чи є змінна порожньою. Якщо змінна порожня, програма повинна вивести повідомлення
про помилку та примусово завершити роботу за допомогою функції exit() і також die().


=====================

Answer

1)
2)
<?php
ini_set('display_errors', 'On');
echo $undefined_variable;
exit;
?>

3)
<?php
ini_set('log_errors', 'On');
ini_set('error_log', 'error.log');

$undefined_variable = 'test';
exit;
?>

4)
<?php
$file = @fopen('non-existent-file.txt', 'r');
echo 'Program continues despite errors';
?>

5)
<?php
ini_set('log_errors', 'On');
ini_set('error_log', 'error.log');

$file = @fopen('non-existent-file.txt', 'r');
echo 'Program continues despite errors';

?>

6)
<?php
function customErrorHandler($errno, $errstr, $errfile, $errline) {
    echo "Error: [$errno] $errstr - $errfile:$errline";
}

set_error_handler("customErrorHandler");

echo $undefinedVariable;

?>

7)
<?php
function customExceptionHandler($exception) {
    echo "Exception: " . $exception->getMessage();
}

set_exception_handler("customExceptionHandler");

throw new Exception("An error occurred");

?>

8)
<?php

// Функція-обробник помилок
function errorHandler($errno, $errstr, $errfile, $errline) {
    echo "<b>Помилка:</b> [$errno] $errstr <br>";
    echo "Файл: $errfile <br>";
    echo "Рядок: $errline <br>";
}

// Реєструємо функцію-обробник помилок
set_error_handler("errorHandler");

// Генеруємо помилку
echo $undefined_variable;

?>

9)
<?php

// Функція-обробник помилок
function errorHandler($errno, $errstr, $errfile, $errline) {
    echo "<b>Помилка:</b> [$errno] $errstr <br>";
    echo "Файл: $errfile <br>";
    echo "Рядок: $errline <br>";
}

// Реєструємо функцію-обробник помилок
set_error_handler("errorHandler");

// Генеруємо помилку
echo $undefined_variable;

// Відновлюємо стандартний обробник помилок
restore_error_handler();

// Генеруємо ще одну помилку
echo $undefined_variable;

?>

10)

<?php

// Функція-обробник помилок
function errorHandler($errno, $errstr, $errfile, $errline) {
    echo "<b>Помилка:</b> [$errno] $errstr <br>";
    echo "Файл: $errfile <br>";
    echo "Рядок: $errline <br>";
}

// Реєструємо функцію-обробник помилок
set_error_handler("errorHandler");

// Генеруємо помилки за допомогою функції trigger_error()
trigger_error("Це помилка з рівнем E_USER_NOTICE", E_USER_NOTICE);
trigger_error("Це помилка з рівнем E_USER_WARNING", E_USER_WARNING);
trigger_error("Це помилка з рівнем E_USER_ERROR", E_USER_ERROR);

?>

11)

<?php

// Функція-обробник помилок
function errorHandler($errno, $errstr, $errfile, $errline) {
    echo "<b>Помилка:</b> [$errno] $errstr <br>";
    echo "Файл: $errfile <br>";
    echo "Рядок: $errline <br>";

    // Використовуємо debug_backtrace() для відстеження викликів функцій
    $trace = debug_backtrace();
    echo "<b>Backtrace:</b><br>";
    foreach ($trace as $i => $t) {
        echo "#$i ".$t['file']."(".$t['line']."): ";
        if (isset($t['class'])) {
            echo $t['class'].$t['type'];
        }
        echo $t['function']."()<br>";
    }
}

// Реєструємо функцію-обробник помилок
set_error_handler("errorHandler");

// Викликаємо неіснуючу функцію
testFunction();

?>
У цій програмі ми створили функцію errorHandler(), яка буде викликатись при виникненні помилок. Ми реєструємо цю функцію
за допомогою set_error_handler().

Далі ми викликаємо неіснуючу функцію testFunction(), що призведе до помилки.

Коли помилка виникає, вона перехоплюється функцією-обробником помилок errorHandler(). Ця функція виводить повідомлення
про помилку на екран, включаючи її рівень, файл і рядок, де сталась помилка.

Далі ми використовуємо функцію debug_backtrace(), щоб відстежити виклики функцій, які призвели до помилки. Ми виводимо
результат виклику цієї функції в масиві $trace за допомогою циклу foreach(). Вивід містить номер ланцюжка викликів
функцій, файл, рядок і назву


12)

<?php

$var = ""; // порожня змінна

if(empty($var)) { // перевіряємо чи є змінна порожньою
    trigger_error("Змінна порожня", E_USER_ERROR); // генеруємо помилку
    exit(); // примусово завершуємо роботу програми
}

echo "Змінна не порожня: " . $var; // виконуємо дії зі змінною
?>