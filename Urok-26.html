<!DOCTYPE html>
<html lang="uk">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Уроки PHP – Класи та об’єкти в PHP</title>
   <link rel="stylesheet" href="assets/css/style.css">

   <!-- hightlight -->
   <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">

   <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
   <!-- and it's easy to individually load additional languages -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js"></script>

   <link rel="stylesheet" href="assets/css/codeHightLight.css">
</head>

<body>
   <div class="post-content">

      <h2>Класи та об’єкти в PHP</h2>

      Сьогодні неможливо уявити процес створення сучасних Web-додатків без розуміння принципів об’єктно-орієнтованого
      програмування (<strong>ООП</strong>). Популярні фреймворки побудовані за об’єктно-орієнтованими принципами,
      використовують компоненти та визначені класи, простори імен та успадкування. Тому ігнорувати або не знати принципи
      ООП не може дозволити собі жоден розробник.<br><a data-fancybox="gallery"
         href="assets/img/php-class-and-object.jpg">
         <img src="assets/img/php-class-and-object.jpg" alt="Класи та об’єкти в PHP" title="Класи та об’єкти в PHP">
      </a><br><strong>Об’єктно-орієнтоване програмування</strong> поряд з визначеними типами (такими як <i>integer</i>,
      <i>boolean</i>, <i>double</i>, <i>string</i>) дозволяє формувати власні абстрактні типи змінних -
      <strong>класи</strong>. Екземпляри класів чи змінні їх типу називаються <strong>об’єктами</strong>. Створюючи
      власні типи даних, можна оперувати не машинними термінами (змінна), а об’єктами реального світу, піднімаючись цим
      на новий абстрактний рівень.<br><br>Не можна виконувати спільні операції з машинами та деревами, проте
      низькорівневий код запросто дозволить зробити таку логічну помилку, тоді як при використанні абстрактних типів
      даних ця операція стає неможливою або принаймні дуже складною. Абстрактні типи даних створені для реалізації
      можливості вводити у програму змінні з бажаними властивостями. Клас описує склад об’єкта - змінні та функції, які
      обробляють і визначають поведінку об’єкта.<h2>Створення класу</h2>У мові програмування PHP клас оголошується за
      допомогою ключового слова <i>class</i>, після якого йдуть унікальне ім’я класу та тіло класу у фігурних дужках.
      Назва не залежить від регістру і може містити будь-яку кількість цифр, букв та символів підкреслення, однак не
      може починатися з цифри. Стандарт кодування <i>PSR</i> вимагає, щоб ім’я класу має бути оголошено з використанням
      так званої <i>СаmеlСаse</i>: кожне слово починається з великої літери, між словами немає роздільників. Докладніше
      можна дізнатися зі статті <a href="https://php.apartner.pro/Urok-16.html" target="_blank">Стандарти, стилі та
         правила
         оформлення коду PHP</a>.
      <pre><code>&lt;?php class MyClass<br>{<br>    // Змінні класу<br>}</code></pre>РНР дозволяє включати скрипти в
      документ за допомогою тегів <i>&lt;?php</i> і <i>?&gt;</i>. Один документ може містити велику кількість включень
      цих тегів, однак клас повинен оголошуватися в одному нерозривному блоці <i>&lt;?php</i> і <i>?&gt;</i>. Не
      вдасться також механічно розбити клас за допомогою інструкції <a
         href="https://www.php.net/manual/en/function.include.php" target="_blank">Include</a> або <a
         href="https://www.php.net/manual/en/function.require.php" target="_blank">Require</a>.<br><br>У тілі класу може
      бути оголошено змінні, які називаються змінними класу. Наприклад, для позначення точки координат можна створити
      клас <i>Map</i>, який містить дві координати <i>$х</i> і <i>$у</i>:
      <pre><code>&lt;?php class Map<br>{<br>    public $x;<br>    public $y;<br>}</code></pre>У скрипті можна лише
      один раз визначити клас. Спроба повторного визначення класу призведе до генерації повідомлення про помилку
      "<i>Fatal error: Cannot declare class Map, because the name is already in use</i>". Цю помилку досить легко
      діагностувати, тобто обидва класи знаходяться в тому самому файлі. Однак, на практиці під кожен клас виділяється
      окремий файл, а у великому проєкті, що складається з десятків класів, використання інструкцій підключення файлів
      може призвести до ситуації, коли той самий файл включається повторно, що призведе також до помилки. Ситуація може
      ускладнюватися тим, що всередині файлів можуть бути розташовані інші конструкції, що включають інші файли. Щоб
      вирішити проблему з повторним визначенням класів, необхідно використовувати <a
         href="https://www.php.net/manual/ru/function.include-once.php" target="_blank">Include_once</a> або <a
         href="https://www.php.net/manual/ru/function.require-once.php" target="_blank">Require_once</a>. Їхня
      відмінність від оригінальних інструкцій полягає в тому, що вони включають файл лише один раз, спроби повторного
      увімкнення файлу ігноруються.

      <h2>Створення об’єкту</h2>Після створення класу можна переходити до створення об’єкта
      цього класу шляхом оголошення за допомогою ключового слова <i>new</i>, за яким слідує ім’я класу. Стандарт
      кодування PSR рекомендує зберігати код класу та використовує його код у різних файлах. Щоб скористатися класом,
      файл, що містить його визначення, слід підключити його за допомогою інструкції <i>require_once</i>:
      <pre><code>&lt;?php require_once 'map.php';<br>$map = new Map;<br>$map-&gt;x = 1;<br>$map-&gt;y = 2;<br>echo $map-&gt;x; // 1</code></pre>
      Об’єкт <i>$map</i> класу <i>Map</i> створюється ключовим словом <i>new</i>. Для звернення до змінних об’єктів
      <i>$х</i> і <i>$у</i>, слід скористатися спеціальним оператором «<i>-&gt;</i>». На відміну від стандартних змінних
      РНР символ <i>$</i> після <i>-&gt;</i> при зверненні до змінних об’єкта не вказується. Після ініціалізації об’єкта
      створюється стандартна змінна <i>$map</i> зі специфічними якостями. Як і будь-якій іншій змінній, об’єкту можна
      надавати нове значення.
      <pre><code>&lt;?php require_once 'map.php';<br>$map = new Map; // object<br>$map = 'str'; // string(3)</code></pre>
      У цьому прикладі об’єкту <i>$map</i> надається рядкове значення, і він стає змінною рядкового типу.<br><br>Як і
      звичайна змінна, об’єкт існує до кінця часу виконання скрипта або поки не буде явно знищений за допомогою
      конструкції <a href="https://www.php.net/manual/ru/function.unset" target="_blank">Unset</a>. Використання
      конструкції <i>Unset</i> може бути корисним, якщо об’єкт займає великий обсяг оперативної пам’яті, і його слід
      звільнити для недопущення переповнення.

      <h2>Властивості та методи</h2>
      Клас може містити змінні, які описують якісь ознаки об’єкта, його стан та які ще називають властивостями або
      атрибутами. Клас може містити функції, які ще називають методами та які визначають його поведінку.<br>
      Так, додамо в клас Person кілька властивостей та методів:
      <pre>
         <code>
            class Person 
            {
               public $name, $age;
               
               function hello() {
                  echo "Hello!<br>";
               }
            }
            
            $tom = new Person ();
            $tom->name = "Tom"; // Встановлення якості $name
            $tom->age  = 36; // Встановлення якості $age
            $personName = $tom->name; // Отримання значення властивості $name
            echo "Ім'я користувача: " . $personName . "<br>";
            $tom->hello(); // виклик методу hello()
            
            print_r( $tom );
         </code>
      </pre>

      Тут клас Person містить дві властивості: $name та $age. Властивості оголошуються як звичайні змінні, перед якими
      стоїть модифікатор доступу – у разі модифікатор public .<br>

      Методи представляють звичайні функції, які виконують певні події. Тут функція hello() просто виводить вітання.<br>
      Після створення об’єкта класу Person:
      <pre>
         <code>
            $tom = new Person();
         </code>
      </pre>
      Ми можемо через ім’я змінної класу звертатися до його властивостей та методів. Щоб звернутися до властивостей та
      методів об’єкта застосовується оператор доступу -> . Наприклад, встановити значення властивостей:

      <pre>
         <code>
            $tom->name = "Tom"; // Встановлення $name
            $tom->age = 36;     // Встановлення $age
         </code>
      </pre>

      Або отримати значення ( наприклад, присвоїти його змінній ):

      <pre>
         <code>
            $personName = $tom->name; // Отримання значення властивості $name
         </code>
      </pre>

      Або викликати методи об’єкта:

      <pre>
         <code>
            $tom->hello(); // виклик методу hello()
         </code>
      </pre>
      У результаті ми отримаємо наступний висновок браузера:

      <pre>
         <code>
            Ім'я користувача: Tom 
            Hello! 
            Person Object ([name] => Tom [age] => 36)
         </code>
      </pre>

      При цьому властивостям можна задати у класі деякі початкові значення:
      <pre>
         <code>
            class Person 
            {
               public $name = "Undefined", $age = 18;
               
               function hello() {
                  echo "Hello!<br>";
               }
            }
            
            $tom = new Person ();
            $tom->age = 36; // Встановлення $age
            
            echo "Ім'я користувача: " . $tom->name . "<br>";
            echo "Вік користувача: " . $tom->age . "<br>";
         </code>
      </pre>

      Висновок брузера:
      <pre>
         <code>
            Ім'я користувача: Undefined 
            Вік користувача: 36
         </code>
      </pre>

      <h2>
         Ключове слово this
      </h2>
      Для звернення до властивостей та методів об’єкта всередині його класу застосовується ключове слово this .
      Наприклад, визначимо в класі метод для виведення інформації про об’єкт:
      <pre>
         <code>
            class Person
            {
               public $name = "Undefined", $age = 18;
               
               function displayInfo()
               {
                  echo "Name:" . $this->name ."; Age: " . $this->age . "<br>";
                  // також можна написати
                  // echo "Name: $this->name; Age: $this->age<br>";
               }
            }
            $tom = New Person ();
            $tom->name = "Tom";
            $tom->displayInfo(); // Name: Tom; Age: 18
         </code>
      </pre>

      Для звернення до полів і методів усередині класу також застосовується оператор доступу -> , перед яким йде $this .
      Причому це $this вказує на поточний об’єкт. Що це означає у практичному плані? Наприклад:

      <pre>
         <code>
            class Person
            { 
               public $name = "Undefined", $age = 18;
                  
               function displayInfo()
               {
                  echo "Name: $this->name; Age: $this->age<br>";
               }
            }
            $tom = new Person();
            $tom->name = "Tom";
            $tom->displayInfo();
            
            $bob = new Person();
            $bob->name = "Bob";
            $bob->age = 25;
            $bob->displayInfo();
         </code>
      </pre>

      При виклику:

      <pre>
         <code>
            $tom->displayInfo();
         </code>
      </pre>

      $this фактично буде вказувати на змінну $tom. Тоді як під час виклику:
      <pre>
         <code>
            $bob->displayInfo();
         </code>
      </pre>

      $this буде вказувати на змінну $bob.<br>

      Висновок браузера:
      <pre>
         <code>
            Name: Tom; Age: 18
            Name: Bob; Age: 25
         </code>
      </pre>

      <h2>Порівняння об’єктів</h2>

      При порівнянні об’єктів класів слід брати до уваги низку особливостей. Зокрема, при використанні оператора
      рівності == два об’єкти вважаються рівними, якщо вони представляють той самий клас та їх властивості мають
      однакові значення.

      А при використанні оператора еквівалентності === обидва об’єкти вважаються рівними, якщо обидві змінні класи
      вказують на той самий екземпляр класу.

      Розглянемо з прикладу:

      <pre>
         <code>
            class Person 
            {
               public $name, $age;
               
               function displayInfo() {
                  echo "Name: $this->name; Age: $this->age<br>";
               }
            }
            
            $tom = new Person ();
            $tom->name = "Tom";
            $tom->age = 36;
            
            $tomas = new Person ();
            $tomas->name = "Tom";
            $tomas->age = 36;
            
            if ( $tom == $tomas ) {
               echo "змінні tom та tomas рівні<br>";
            } else {
               echo "змінні tom та tomas НЕ рівні";
            }
            
            if ( $tom === $tomas ) {
               echo "змінні tom та tomas еквівалентні";
            } else {
               echo "змінні tom та tomas не еквівалентні";
            }
         </code>
      </pre>

      Тут порівнюються дві змінні – $tom та $tomas. Вони представляють той самий клас Person, та його властивості мають
      одні й самі значення. Однак вони репрезентують різні об’єкти. Тому при порівнянні оператор == поверне true, а
      оператор === – false:

      <pre>
         <code>    	
            змінні tom і tomas рівні 
            змінні tom і tomas НЕ еквівалентні
         </code>
      </pre>

      Візьмемо інший приклад, коли обидві змінних представляють той самий об’єкт:

      <pre>
         <code>
            $person = new Person();

            $tom       = $person;
            $tom->name = "Tom";
            $tom->age  = 36;
            
            $tomas = $person;
            
            if ( $tom == $tomas ) {
               echo "змінні tom і tomas рівні<br>";
            } else {
               echo "змінні tom і tomas НЕ рівні";
            }
            
            if ( $tom === $tomas ) {
               echo "змінні tom і tomas еквівалентні";
            } else {
               echo "змінні tom і tomas не еквівалентні";
            }
         </code>
      </pre>

      Тут об’єкт класу Person створюється лише один раз: $person = new Person();. Та потім обидві змінні $tom і $tomas
      будуть вказувати на цей об’єкт. При цьому немає значення, для якої саме змінної ми встановлюємо властивості. Так
      як насправді це буде той самий об’єкт.<br>
      У результаті оператор ==, та оператор === при порівнянні повернуть true
      <pre>
         <code>
            змінні tom і tomas рівні 
            змінні tom і tomas еквівалентні
         </code>
      </pre>




      <h2>Специфікатори доступу</h2>Змінні класу оголошуються за допомогою
      специфікаторів <i>public</i>, <i>private</i> або <i>protected</i>, які вказують на доступ до змінних об’єктів
      ззовні. Відкриті члени класу оголошуються специфікатором доступу <i>public</i> і доступні як усередині класу, так
      і ззовні. Закриті методи та члени класу оголошуються за допомогою специфікатора <i>private</i> та доступні лише у
      межах класу. Специфікатор <i>protected</i> використовується при успадкуванні (розглянемо далі).
      <pre><code>&lt;?php class PrivateMap<br>{<br>    public $x;<br>    private $y;<br>}<br>// Оголошуємо об’єкт класу PrivateMap<br>$map = new PrivateMap;<br><br>// Присвоюємо значення змінним об’єкта<br>$map-&gt;x = 1;<br>$map-&gt;y = 2; // Fatal error: Uncaught Error: Cannot access private property PrivateMap</code></pre>
      У цьому прикладі клас містить відкриту змінну <i>$х</i> і закриту <i>$у</i>. Звернення до закритого члена класу
      <i>$у</i> завершиться помилкою "<i>Fatal error: Uncaught Error: Cannot access private property PrivateMap</i>".
      <h2>Статичні змінні класу</h2>Кожен об’єкт має власний набір змінних, незалежних від інших об’єктів. Але можна
      створити статичні змінні на рівні класу, які оголошуються за допомогою ключового слова <i>static</i>. Особливістю
      таких змінних є можливість їх ініціалізації у класі при оголошенні:
      <pre><code>&lt;?php class MyStatic<br>{<br>    public static $staticvar = 50;<br>}</code></pre>Звертатися до
      таких змінних можна без створення об’єктів за допомогою оператора доступу видимості «<i>::</i>»:
      <pre><code>echo MyStatic::$staticvar; // 50</code></pre>
      <h2>Посилання на змінні</h2>Якщо надавати змінним однакові значення за допомогою оператора, виходять дві незалежні
      змінні:
      <pre><code>&lt;?php $first = $second = 1;<br>$first = 2;<br>echo $second; // 1</code></pre>Працюючи з об’єктами
      ситуація зовсім інша. Оператор присвоєння <i>=</i> не призводить до створення нової копії об’єкта: і старий, і
      новий об’єкт вказують на ту саму область пам’яті:
      <pre><code>&lt;?php require_once 'map.php';<br><br>$first = new Map;<br>$first-&gt;x = 3;<br>$first-&gt;y = 3;<br><br>$second = $first;<br>$second-&gt;x = 5;<br>$second-&gt;y = 5;<br>echo "x: {$first-&gt;x}, y: {$first-&gt;y}";</code></pre>
      Присвоєння нових значень змінним одного об’єкта призводить до того, що ці значення отримує і другий об’єкт. Тобто
      змінні <i>$first</i> і <i>$second</i> посилаються на той самий об’єкт.<br><br>В цьому випадку замість того, щоб
      кожен раз передавати об’єкт, як це відбувається у випадку звичайних змінних, передається посилання на об’єкт. Це
      дозволяє значно прискорити виконання скриптів, особливо, коли об’єкт потрібно передати через межу області
      видимості.<h2>Клонування об’єктів</h2>Якщо потрібно створити копію поточного об’єкта, використовується спеціальна
      операція - клонування. Вона виконується за допомогою ключового слова <i>clone</i>, яке розташовується
      безпосередньо перед об’єктом клонування:
      <pre><code>&lt;?php require_once 'map.php';<br><br>$first = new Map;<br>$first-&gt;x = 3;<br>$first-&gt;y = 3;<br><br>$second = clone $first;<br>$second-&gt;x = 5;<br>$second-&gt;y = 5;<br><br>echo "x: {$first-&gt;x}, y: {$first-&gt;y}"; // x: 3, y: 3</code></pre>
      <h2>Методи</h2>Найбільш корисною властивістю класів є можливість оголошення всередині них функцій, які можуть
      виконувати операції над даними об’єктом, викликати інші функції об’єкта. Такі функції називають методами.<h2>
         Визначення методу</h2>Крім змінних у класи можна включати методи, які є звичайними функціями РНР. Наведемо
      приклад класу <i>Hello</i>, до складу якого входить метод <i>Greet</i>, який повертає повідомлення «<i>Hello,
         world!</i>»:
      <pre><code>&lt;?php class Hello<br>{<br>    public function greet()<br>    {<br>        return 'Hello, world!';<br>    }<br>}</code></pre>
      Звернутися до методу можна, аналогічно змінним, за допомогою оператора <i>-&gt;</i>:
      <pre><code>$obj = new Hello;<br>echo $obj-&gt;greet(); // Hello, world!</code></pre>
      <h2>Звернення до змінних об’єктів</h2>Для того, щоб звернутися до змінних або інших методів усередині методу,
      використовується спеціальна змінна <i>$this</i>, після якої слідують оператор <i>-&gt;</i> і назва змінної або
      класу. Для оголошення закритих змінних, доступних тільки всередині класу або об’єкта, використовується
      специфікатор доступу <i>Private</i>, а для відкритих - специфікатор доступу <i>Public</i>. Специфікатори можуть
      використовуватись і щодо методів.<br><br>Наведемо приклад використання закритих методів класу:
      <pre><code>&lt;?php class Sum<br>{<br>    private $x;<br><br>    public function setX($x)<br>    {<br>        $this-&gt;x = $x;<br>    }<br><br>    public function getX()<br>    {<br>        return $this-&gt;x;<br>    }<br><br>    public function result()<br>    {<br>        return $this-&gt;getX() + 2;<br>    }<br>}<br>$sum = new Sum;<br>$sum-&gt;setX(2);<br>echo $sum-&gt;result(); // 4</code></pre>
      Оскільки змінна <i>$х</i> доступна лише всередині методів класу <i>Sum</i>, то звернутися безпосередньо через
      об’єкт <i>echo $sum-&gt;x</i> вже не вийде, і користувач побачить помилку: <i>Fatal error: Uncaught Error: Cannot
         access private property Sum</i>. Для цього можна використовувати метод-аксесор, який встановлює нове значення
      змінної <i>$х</i>:
      <pre><code>void setX(int $x)</code></pre>Крім вище описаного методу, у прикладі використовується додатковий метод
      <i>Result</i>, який додає до значення змінної <i>$x</i> значення 2.<h2>Статичні методи</h2>До поточного моменту
      використовувалися методи об’єкта, які можна викликати лише після того, як об’єкт класу створювався за допомогою
      конструкції <i>New</i>. Навіть коли методи викликають інші методи за допомогою <i>$this-&gt;</i>, вони все одно
      звертаються до поточного об’єкта і не можуть бути викликані раніше, ніж після його створення. Однак, РНР надає
      спосіб використання методу без об’єктів. Для цього метод слід оголосити статичним за допомогою ключового слова
      <i>Static</i>:
      <pre><code>&lt;?php class Greet<br>{<br>    public static function hello()<br>    {<br>        return 'Hello, world!';<br>    }<br>}</code></pre>
      РНР допускає будь-який порядок проходження специфікаторів доступу та ключового слова <i>Static</i> перед ім’ям
      функції. Однак, відповідно до вимог <i>PSR</i>, ключове слово <i>Static</i> завжди розташовується після
      специфікаторів доступу.<br><br>Для виклику статичного методу необхідно перед ім’ям класу необхідно додати оператор
      дозволу області видимості «<i>::</i>»:
      <pre><code>echo Greet::hello(); // Hello, world!</code></pre>
      <h2>Ключове слово self</h2>Всередині методу класу, щоб послатися на статичну змінну цього класу, не обов’язково
      використовувати ім’я класу перед оператором дозволу області видимості. Замість нього може використовуватись
      ключове слово <i>self</i>:
      <pre><code>&lt;?php class Greet<br>{<br>     public static function hello()<br>     {<br>         return 'Hello, world!';<br>     }<br>     public static function result()<br>     {<br>         return self::hello();<br>     }<br>}<br>echo Greet::result(); // Hello, world!</code></pre>
      Варіант із <i>Self</i> дозволяє перейменовувати клас без численних виправлень і, як правило, коротший у написанні.
      <h2>Спеціальні методи</h2>Клас може містити ряд спеціальних методів, що викликаються неявно при створенні,
      видаленні об’єкта, при зверненні до його змінних та методів. Існує можливість розробнику перевизначити ці методи і
      цим втрутитися у життєвий цикл об’єкта. Такі спеціальні методи у співтоваристві називають магічними методами, а
      щоб відрізнити їх від інших методів, їхня назва передується двома символами підкреслення, наприклад,
      <i>__constructor()</i>.<h2>Конструктор __construct()</h2>При створенні об’єкта до виклику інших нестатичних
      методів класу можна автоматично виконати спеціальний метод класу під назвою конструктор, який використовується
      головним чином для ініціалізації об’єкта, забезпечуючи узгоджений стан об’єкта перед початком роботи. Для
      оголошення конструктора класа необхідно створити метод з ім’ям «<i>__construct()</i>». Наведемо приклад, де при
      оголошеннях класу <i>Constructor</i>, що містить конструктор, буде виведено повідомлення "<i>Виклик
         конструктора</i>" та ініціалізується закритий член <i>$var</i>.
      <pre><code>&lt;?php class Constructor<br>{<br>    private $var;<br><br>    public function __construct()<br>    {<br>        echo 'Виклик конструктора';<br>        $this-&gt;var = 5;<br>    }<br>}<br>$obj = new Constructor;<br>print_r($obj);</code></pre>
      Результатом роботи скрипта є наступні рядки:
      <pre><code>Виклик конструктора<br>Constructor Object<br>(<br>    [var:Constructor:private] =&gt; 5<br>)</code></pre>
      Конструктор виконується автоматично під час виконання оператора <i>New</i>. Це дозволяє розробнику класу бути
      впевненим, що змінні класу отримають коректну ініціалізацію.<br><br>Зазвичай в об’єктно-орієнтованих мовах
      програмування явний виклик конструктора взагалі не допускається, оскільки це суперечить принципу інкапсуляції,
      однак у РНР конструктор можна викликати не лише у самому класі, але й із зовнішнього коду. Але слід уникати
      маніпулювання конструктором напряму. Якщо одні й тіж самі дії можуть виконуватися як конструктором, і будь-яким
      іншим методом, краще визначити окремий метод до виконання цього набору дій.<h2>Параметри конструктора</h2>При
      оголошенні об’єкта в круглих дужках після імені класу можна вказати параметри, які може приймати конструктор так
      само, як будь-який інший метод. Для прикладу продемонструємо клас <i>Map</i>, який має закриту змінну <i>$х</i> і
      конструктор, який ініціалізує закритий член класу:
      <pre><code>&lt;?php class Map<br>{<br>    private $x;<br><br>    public function __construct($x)<br>    {<br>        $this-&gt;x = $x;<br>    }<br>    public function getX()<br>    {<br>        return $this-&gt;x;<br>    }<br>}<br>$obj = new Map(5);<br>echo $obj-&gt;getX();</code></pre>
      Важливо, що якщо не вказати аргумент при оголошенні об’єкта, то буде помилка "<i>Fatal error: Uncaught
         ArgumentCountError: Too few arguments to function Map::__construct()</i>". Однак, можна використовувати
      необов’язкові параметри. У наступному прикладі закрита змінна <i>$х</i> отримує значення 0, якщо значення не
      встановлюється через параметри конструктора.
      <pre><code>public function __construct($x = 0)<br>{<br>    $this-&gt;x = $x;<br>}</code></pre>
      <h2>Деструктоp __destruct()</h2>Деструктор – це спеціальний метод класу, який автоматично виконується у момент
      знищення об’єкта. Цей метод викликається завжди останнім і використовується головним чином для коректного
      звільнення зарезервованих конструктором ресурсів. Для оголошення деструктора у класі необхідно створити метод з
      ім’ям «<i>__destruct()</i>»:
      <pre><code>&lt;?php class Destructor<br>{<br>    public function __destruct()<br>    {<br>        echo 'Виклик деструктора';<br>    }<br>}<br>$obj = new Destructor();</code></pre>
      Як можна бачити, деструктор виконується в останню чергу і знищує об’єкт при завершенні скрипту. Насправді
      деструктор використовується досить рідко, навіть у ситуаціях, де міг бути корисним. Справа в тому, що деструктор
      викликається лише у тому випадку, коли об’єкт штатно збирається збирачем сміття. Ця подія може статися далеко не
      відразу або взагалі не наступити, якщо виникає помилка, виняткова ситуація або скрипт завершується ззовні.<h2>
         Методи-аксесори __set() та __get()</h2>Використання переважно закритих змінних, доступ яких здійснюється через
      відкриті методи, дозволяє приховати внутрішню реалізацію класу. PHP надає можливість використовувати спеціальні
      методи «<i>__set()</i>» і «<i>__get()</i>» - аксесори, звернення до яких виглядає так само, як до відкритих
      змінних класу.<br><br>Метод <i>__get()</i> призначений для реалізації читання властивості, приймає єдиний
      параметр, який є ключем. Метод <i>__set()</i> дозволяє присвоїти властивості нове значення і приймає два
      параметри, перший із яких є ключем, а другий - значенням властивості.<br><br>Наведемо приклад, у якому з допомогою
      методу <i>__set()</i> об’єкту присвоюються нові властивості, які поміщаються у масив <i>$this-&gt;arr</i>, а
      перевантажений метод <i>__get()</i> дозволяє витягти їх із масиву.
      <pre><code>&lt;?php class Accessor<br>{<br>    private $arr = [];<br><br>    public function __get($key)<br>    {<br>        return $this-&gt;arr[$key];<br>    }<br><br>    public function __set($key, $value)<br>    {<br>        $this-&gt;arr[$key] = $value;<br>    }<br>}<br><br>$obj = new Accessor();<br><br>$obj-&gt;name = 'Hello, world!';<br>$obj-&gt;color = 'Red';<br><br>echo $obj-&gt;name;<br><br>echo "&lt;pre&gt;";<br>print_r($obj);<br>echo "&lt;/pre&gt;";</code></pre>
      Результатом роботи скрипта є наступні рядки:
      <pre><code>Hello, world!<br>Accessor Object<br>(<br>    [arr:Accessor:private] =&gt; Array<br>        (<br>            [name] =&gt; Hello, world!<br>            [color] =&gt; Red<br>        )<br><br>)</code></pre>
      Клас <i>Accessor</i> перехоплює всі звернення до властивостей об’єкта та створює відповідний елемент у закритому
      масиві <i>$arr</i>. Будь-яка спроба привласнити властивості значення призводить до створення нового елемента
      закритого масиву <i>$arr</i>.<h2>Динамічні методи</h2>Спеціальний метод «<i>__call()</i>» призначений для
      створення динамічних методів: якщо в класі не перевантажено метод <i>__call()</i>, звернення до неіснуючого методу
      не призведе до помилки, а передасть керування методом <i>__call()</i>. Як перший параметр метод __call() приймає
      ім’я викликаного методу, а як другий - масив, елементами якого є параметри, передані при виклику.<br><br>За
      допомогою спеціального методу <i>__call()</i> можна емулювати методи зі змінною кількістю параметрів. Для прикладу
      створимо клас <i>MinMax</i>, який надає користувачеві два методи: <i>min()</i> і <i>max()</i>, що приймають
      довільну кількість числових параметрів та визначають мінімальне та максимальне значення відповідно.
      <pre><code>&lt;?php class MinMax<br>{<br>    public function __call($method, $arg)<br>    {<br>        if (!is_array($arg)) {<br>            return false;<br>        }<br>        $value = $arg[0];<br>        if ($method == 'min') {<br>            for ($i = 0; $i &lt; count($arg); $i++)<br>            {<br>                if ($arg[$i] &lt; $value) {<br>                    $value = $arg[$i];<br>                }<br>            }<br>        }<br>        if ($method == 'max') {<br>            for ($i = 0; $i &lt; count($arg); $i++) {<br>                if ($arg[$i] &gt; $value) {<br>                    $value = $arg[$i];<br>                }<br>            }<br>        }<br>        return $value;<br>    }<br>}<br><br>$obj = new MinMax();<br>echo $obj-&gt;min(3, 7, 1, 2, 9, 5); // 1<br>echo '&lt;br /&gt;';<br>echo $obj-&gt;max(3, 7, 1, 2, 9, 5); // 9</code></pre>
      Залежно від методу - <i>min()</i> або <i>max()</i> - використовуються два різні алгоритми для пошуку результату.
      Крім того, для класу <i>MinMax</i> допустимий виклик методу з довільним ім’ям, і, якщо воно відмінне від
      <i>min</i> або <i>max</i>, буде повертатися перший аргумент. Незалежно від імені методу, якщо не передано жодного
      аргументу, повертається значення <i>False</i>.<br><br>За аналогією зі спеціальним методом <i>__call()</i> існує
      статичний варіант <i>__callStatic()</i>, що дозволяє динамічно створювати статичні методи. Наведемо приклад
      реалізації класу <i>MinMax</i>, в якому методи <i>min()</i> і <i>max()</i> визначаються як статичні:
      <pre><code>&lt;?php class MinMax<br>{<br>    public static function __callStatic($method, $arg)<br>    {<br>        if (!is_array($arg)) {<br>            return false;<br>        }<br>        $value = $arg[0];<br>        if ($method == 'min') {<br>            for ($i = 0; $i &lt; count($arg); $i++)<br>            {<br>                if ($arg[$i] &lt; $value) {<br>                    $value = $arg[$i];<br>                }<br>            }<br>        }<br>        if ($method == 'max') {<br>            for ($i = 0; $i &lt; count($arg); $i++) {<br>                if ($arg[$i] &gt; $value) {<br>                    $value = $arg[$i];<br>                }<br>            }<br>        }<br>        return $value;<br>    }<br>}<br><br>$obj = new MinMax();<br>echo $obj::min(3, 7, 1, 2, 9, 5); // 1<br>echo '&lt;br /&gt;';<br>echo $obj::max(3, 7, 1, 2, 9, 5); // 9</code></pre>
      <h2>Інтерполяція об’єкту</h2>Спеціальний метод <i>__toString()</i> дозволяє інтерполувати (підставляти) об’єкт у
      рядок. Аналогічно змінним, для підстановки значень яких необхідно укласти рядок у подвійні лапки, такої ж
      поведінки можна домогтися і від об’єкта, якщо реалізувати у його класі метод <i>__toString()</i>, який перетворює
      об’єкт у рядок. Слід звернути увагу. що метод <i>__toString()</i> виводить результат з допомогою конструкції
      <i>return</i>, а не <i>echo</i>.
      <pre><code>public function __toString() {<br>    return "({$this-&gt;x})";<br>}</code></pre>Слід зазначити, що
      виклик об’єкта в рядковому контексті можливий, тільки якщо його клас містить реалізацію методу <i>__toString</i>,
      інакше спроба використовувати об’єкт у рядку буде закінчуватися помилкою "<i>Recoverable fatal error: Object of
         class Point could not be converted to string</i>".<h2>Успадкування</h2>Використання повторного коду є однією з
      головних цілей об’єктно-орієнтованого підходу та один із механізмів реалізації полягає у використанні
      успадкування.<br><br>Суть спадкування полягає у можливості створення нового класу на основі вже існуючого,
      автоматично включивши до нового класу змінні та методи старого. При цьому "старий" клас називається базовим, а
      новостворений клас - похідним. Під час оголошення похідного класу необхідно вказати ім’я базового класу за
      допомогою ключового слова <i>extends</i>. Наведемо приклад, у якому буде створено клас <i>Base</i> і клас
      <i>Derived</i>, який успадковуватиме перший клас.
      <pre><code>&lt;?php class Base<br>{<br>    public $first;<br>    public function printFirst()<br>    {<br>        echo $this-&gt;first;<br>    }<br>}<br>class Derived extends Base<br>{<br>    public $second;<br>    public function printSecond()<br>    {<br>        echo $this-&gt;second;<br>    }<br>}<br><br>$obj = new Derived;<br><br>$obj-&gt;first = 100;<br>$obj-&gt;second = 200;<br><br>$obj-&gt;printFirst(); // 100<br>$obj-&gt;printSecond(); // 200</code></pre>
      У базовому класі <i>Base</i> містяться змінна $first та метод <i>printFirst</i>. Від класу <i>Base</i>
      успадковується клас <i>Derived</i>, що містить змінну <i>$second</i> та метод <i>printSecond</i>. Похідний клас, у
      свою чергу, може виступати як базовий для інших класів. В результаті можна отримати розгалужену ієрархію класів,
      розширюючи функціональність без повторного створення змінних та методів, використовуючи наявні з існуючих класів.
      <h2>Специфікатори доступу та успадкування</h2>Всі змінні та методи зі специфікаторами доступу <i>public</i> і
      <i>private</i> при успадкування поводяться по відношенню до похідного класу так само, як і зовнішній код щодо
      об’єкта. Це означає, що з похідного класу доступні всі змінні методи, оголошені зі специфікатором доступу
      <i>public</i>, і не доступні компоненти, оголошені як <i>private</i>.<br><br>Іноді зручно, щоб змінна або метод
      базового класу залишаючись закритими для зовнішнього коду, були відкриті для похідного класу. У цьому випадку
      вдаються до специфікатора доступу <i>protected</i>. Забезпечені ним компоненти класи називають захищеними.<h2>
         Перевантаження методів</h2>У похідному класі можна створити метод з такою самою назвою, що й у базовому класі,
      який замінить метод базового класу під час виклику. Така процедура називається перевантаження методів. Однак у
      рамках похідного класу залишається можливість викликати метод базового класу, звернувшись щодо нього з допомогою
      префікса <i>parent::</i>. За допомогою навантаження методу можна розширити метод базового класу, так і повністю
      замінити його вже новим.<h2>Пізнє статичне зв’язування</h2>При успадкування класів слід приділяти особливу увагу
      статичним методам. Ключове слово <i>self</i> дозволяє посилатися на статичний метод і завжди посилається на
      поточний клас, його не можна звернутися до статичним методам базового класу. РНР надає спеціальне ключове слово
      <i>static</i>, яке можна використовувати замість <i>self</i> і звертатися до статичним методам базового
      класу.<br><br>
   </div>
   <div class="task">
      <br>
      Завдання:<br>
      Спробувати створити<br>
      1) Створення класу<br>
      2) Створення об’єкту<br>
      3) Специфікатори доступу<br>
      4) Статичні змінні класу<br>
      5) Посилання на змінні<br>
      6) Клонування об’єктів<br>
      7) Методи<br>
      8) Визначення методу<br>
      9) Звернення до змінних об’єктів<br>
      10) Статичні методи<br>
      11) Ключове слово self<br>
      12) Спеціальні методи<br>
      13) Конструктор __construct()<br>
      14) Параметри конструктора<br>
      15) Деструктоp __destruct()<br>
      16) Методи-аксесори __set() та __get()<br>
      17) Динамічні методи<br>
      18) Інтерполяція об’єкту<br>
      19) Успадкування<br>
      20) Повторити пройдений матеріал<br>
      <br>
      <br>
   </div>

   <script src="assets/js/app.js"></script>
</body>

</html>