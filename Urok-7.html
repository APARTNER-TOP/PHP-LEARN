<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Суперглобальні масиви в PHP</title>
   <link rel="stylesheet" href="assets/css/style.css">
</head>

<body>
   <div class="post-content">
      Процес обміну за протоколом НТТР між браузером і сервером прихований від розробника та реалізується за допомогою
      автоматичних механізмів та інструментів - суперглобальних масивів, які являють собою зумовлені масиви, що
      створюються та заповнюються Wеb-сервером та РНР.<br><a data-fancybox="gallery"
         href="assets/img/super-globalni-masuvu-v-php.jpg">
         <img src="assets/img/super-globalni-masuvu-v-php.jpg" alt="Суперглобальні масиви в PHP" />
      </a>
      <h2>Типи суперглобальних масивів</h2>Суперглобальні масиви не обмежені областями видимості функцій та класів і є
      глобальними. Опишемо повний перелік таких масивів:<br><br>- <i>$_GET</i> - масив із GЕТ-параметрами, тобто дані,
      передані через рядок запиту;<br><br>- <i>$_POST</i> - масив із РОSТ-параметрами, передані в тілі НТТР-документа,
      відправленого на сервер методом <i>POST</i>;<br><br>- <i>$_FILES</i> - масив із параметрами завантаженого на
      сервер файлу;<br><br>- <i>$_COOKIE</i> - масив, який забезпечує доступ до даних <i>Cookies</i>, що зберігаються на
      стороні клієнта та передаються з кожним НТТР-запитом на сервер;<br><br>- <i>$_SESSION</i> - масив, який забезпечує
      доступ до механізму сесій, так само як і <i>Cookies</i>, призначений для зберігання інформації під час переходу
      від однієї сторінки до іншої. При цьому вся інформація зберігається на сервері, а клієнт обмінюється із сервером
      лише ідентифікатором сесії;<br><br>- <i>$_REQUEST</i> - масив із параметрами, передані скрипту методами
      <i>POST</i>, <i>GET</i>, а також через <i>Cookie</i>;<br><br>- <i>$_ENV</i> - масив із змінними оточення,
      переданий скрипту Wеb-сервером або командною оболонкою;<br><br>- <i>$_SERVER</i> - масив з інформацією про
      місцезнаходження скрипта, передані йому параметри, сервер, під керуванням якого працює РНР-скрипт, інформацію,
      передану з НТТР-заголовків клієнтів;<br><br>- <i>$_GLOBALS</i> - масив зі змінними з глобальною областю видимості,
      включаючи значення з масивів <i>$_GET</i>, <i>$_POST</i>, <i>$_COOKIE</i> та <i>$_FILES</i>.<h2>Cookie</h2>
      Протокол <i>НТТР</i>, що лежить в основі Інтернету, не зберігає інформації про стан сеансу і будь-яке звернення
      клієнта сприймає сервером як звернення нового клієнта. Для розрізнення користувачів було введено механізм
      <i>Cookie</i>. Його робота полягає в наступному: сервер надсилає клієнту НТТР-заголовок <i>Set-Cookie</i> з ім’ям,
      значенням та необов’язковим терміном дії. Браузер, після отримання цього заголовка - зберігає ім’я та значення або
      в оперативній пам’яті або в текстовому файлі, якщо куки необхідні і в наступних сеансах. При кожному новому запиті
      клієнт надсилає серверу НТТР-заголовок <i>cookie</i> з ключем та значенням.<div class="notice">Слово <i>Cookie</i>
         з англійської перекладається як «<i>кекс</i>» або солодкий бонус, що видається клієнтам ресторану, щоб вони
         запам’ятали його та відвідали вдруге.</div>Для встановлення <i>Cookie</i> достатньо скористатися функцією <a
         href="https://www.php.net/manual/en/function.setcookie" target="_blank">Setcookie</a>, яка приймає ім’я
      <i>Cookie</i> та значення; час у секундах, що пройшли з 0 годин 00 хвилин 1 січня 1970; шлях і домен, яким
      доступний <i>Cookie</i>; спосіб передачі через протокол <i>HTTP</i> або <i>HTTPS</i> і можливість видимості
      <i>JavaScript</i>.<br><br>Після встановлення <i>Cookie</i>, значення можна отримати на всіх сторінках
      Wеb-програми, звертаючись до суперглобального масиву <i>$_COOKIE</i> і використовуючи як ключ ім’я <i>Cookie</i>.
      <div class="notice">Оскільки <i>Cookie</i> передається в заголовку НТТР-запиту, виклик функції <i>Setcookie</i>
         необхідно розміщувати до початку виведення інформації у вікно браузера функціями <i>Echo</i>, <i>Print</i> та
         іншими, а також до включення у файл НТМL-тегів.</div>Якщо виставляється час життя <i>Cookie</i>, дані
      записуються на жорсткому диску клієнта, інакше <i>Cookie</i> розміщується в оперативній пам’яті і діє тільки до
      кінця сеансу, тобто до того моменту, поки користувач не закриє вікно браузера. У цьому випадку говорять про
      сесійну <i>Cookie</i>.<br><br>Продемонструємо роботу з <i>Cookie</i> без встановлення часу життя:
      <pre><code>&lt;?php<br>setcookie('counter', counter());<br>// Виводимо значення cookie<br>echo "Ви відвідали цю сторінку {$_COOKIE['counter']} разів";<br><br>function counter() {<br>    if (isset($_COOKIE['counter'])) {<br>        ++$_COOKIE['counter'];<br>    } else {<br>        $_COOKIE['counter'] = 1;<br>    }<br>    return $_COOKIE['counter'];<br>}</code></pre>
      У цьому прикладі при кожному зверненні до сторінки встановлюється нове значення <i>Cookie</i> з ім’ям
      <i>Counter</i>. У цьому значення <i>Cookie</i> обчислюється з допомогою функції <i>Counter</i>. У разі першого
      звернення значення <i>$_COOKIE['counter']</i> не встановлено, функція повертає значення 1. При наступних
      зверненнях, коли відвідувач надсилає значення <i>Cookie</i> з кожним запитом, <i>$_COOKIE['counter']</i>
      повертатиме надіслане значення, яке буде збільшено на одиницю.<h2>Сесії</h2>Сесії зберігаються у вигляді пар
      «<i>ключ/значення</i>», але, на відміну від <i>Cookie</i>, дані в сесії зберігаються на стороні сервера, що робить
      їх використання кращим варіантом, ніж <i>Cookies</i>. Для кожного з відвідувачів зберігається власний набір даних
      як унікальний номер ідентифікатора сесії (<i>SID</i>), який передається через <i>Cookies</i>. До основних
      недоліків сесій відноситься складність контролю часу їхнього життя з РНР-скриптів, тобто цей параметр задається в
      конфігураційному файлі <i>php.ini</i> директивою <i>Session.cookie_lifetime</i> і може бути заборонений для зміни
      зі скрипту. Обидва механізми, сесії та <i>Cookies</i> взаємно доповнюють один одного. <i>Cookies</i> зберігаються
      на комп’ютері відвідувача, і тривалість їхнього життя визначає розробник. Зазвичай вони застосовуються для
      довгострокових завдань (від кількох годин) та зберігання інформації, що відноситься виключно до конкретного
      відвідувача. Сесії зберігаються на сервері і тривалість їх існування визначає адміністратор. Вони призначені для
      короткострокових завдань зберігання та обробки інформації про всіх відвідувачів загалом. Тому використовувати той
      чи інший механізм слід залежно від поставленої мети.<div class="notice">Крім традиційного зберігання сесій на
         жорсткому диску в директорії, сесії допускають альтернативні механізми зберігання.</div>Директива
      <i>Session.save_path</i> у конфігураційному файлі <i>php.ini</i> дозволяє задати шлях до каталогу, де зберігаються
      файли сесій. Перед тим як почати працювати з сесією, клієнту має бути встановлений <i>Cookie</i> з унікальним
      ідентифікатором <i>SID</i>, а на сервері має бути створено файл із даними сесії. Усі ці початкові дії виконує
      функція <a href="https://www.php.net/manual/en/function.session-start" target="_blank">Session_start</a>. Вона має
      викликатись на кожній сторінці, де відбувається звернення до сесії. Так само, як і функція <i>Setcookie</i>,
      функція <i>Session_start</i> повинна викликатися до початку виведення інформації у вікно браузера.<div
           class="notice">При установці директиви <i>Session.auto_start</i> конфігураційного файлу <i>php.ini</i> у
         значення 1, можна досягти автоматичного старту сесії без виклику функції Session_start.</div>Після
      ініціалізації сесії з’являється можливість зберігати інформацію у суперглобальному масиві <i>$_SESSION</i>:
      <pre><code>&lt;?php<br>session_start();<br>$_SESSION['name'] = 'value';</code></pre>На сторінках, де відбувається
      виклик <i>Session_start</i>, значення цих змінних можна вилучити з суперглобального масиву
      <i>$_SESSION</i>.<br><br>Масив <i>$_SESSION</i> перед збереженням у файл піддається серіалізації, тому зберігати
      серіалізовані дані в сесії вкрай не рекомендується, тобто масиви, що двічі поспіль піддаються дії функції
      <i>Serialize</i>, найчастіше відновленню не підлягають.<br><br>Для завершення роботи сесії необхідно викликати
      функцію <a href="https://www.php.net/manual/en/function.session-destroy" target="_blank">Session_destroy</a>, яка
      повертає <i>True</i> при успішному знищенні сесії та <i>False</i> – інакше. Якщо нема потреби знищувати поточну
      сесію, а потрібно лише обнулити всі значення, що зберігаються у сесії, слід викликати функцію <a
         href="https://www.php.net/manual/en/function.unset" target="_blank">Unset</a>. Так само знищується окремий
      елемент суперглобального масиву <i>$_SESSION</i>:
      <pre><code>unset($_SESSION['name'])</code></pre>
      <h2>Змінні оточення</h2>Під змінними оточення розуміються певні параметри, які можуть задаватися лише на рівні
      командної оболонки. Для цього необхідно звернутися до суперглобального масиву <i>$_ENV</i>. Проте, щоб значення
      змінної оточення з’явилося в <i>$_ENV</i>, необхідно зробити кілька кроків.<br><br>У файлі <i>php.ini</i> слід
      знайти директиву <i>Variables_order</i> і переконатися, що вона містить у своєму значенні букву <i>Е</i>.
      Директива визначає, які суперглобальні масиви будуть доступні до скрипту.
      <pre><code>Variables_order = "EGPCS"</code></pre>У прикладі вище значення директиви містить символи <i>Е</i>,
      <i>G</i>, <i>Р</i>, <i>С</i> та <i>S</i>, отже, у скрипті будуть доступні суперглобальні масиви <i>$_ENV</i>,
      <i>$_GET</i>, <i>$_POST</i>, <i>$_COOKIE</i> та <i>$_SERVER</i>. Варто прибрати одну з букв, і відповідний
      суперглобальний масив завжди буде порожнім. Після того, як змінна оточення передана серверу, до неї можна
      звернутися з РНР-скрипту як до звичайного значення масиву:
      <pre><code>$_ENV['HELLO'] = 'World';<br>echo $_ENV['HELLO']; // World</code></pre>
      <h2>Масив $_SERVER</h2>Масив <i>$_ENV</i> відповідає за зовнішні змінні оточення. Проте РНР містить безліч
      внутрішніх параметрів, параметрів формування НТТР-заголовків відповіді, і навіть параметрів, витягнутих з НТТР
      заголовків, надісланих клієнтом. Усі вони містяться у суперглобальному масиві <i>$_SERVER</i>.<br><br>Елемент
      <i>$_SERVER['DOCUMENT_ROOT']</i> містить шлях до кореневого каталогу сервера. При виконанні скрипта у віртуальному
      хості, в цьому елементі, як правило, вказується шлях до кореневого каталогу віртуального хоста.<br><br>В елементі
      <i>$_SERVER['HTTP_ACCEPT']</i> описуються переваги клієнта щодо типу документа. Вміст цього елемента витягується з
      НТТР заголовка <i>Accept</i>, який надсилає клієнт до сервера. Заголовок <i>Accept</i> дозволяє уточнити медіатип,
      який вважає за краще отримати клієнт у відповідь на свій запит. Наприклад:
      <pre><code>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</code></pre>Символ <i>*</i>
      використовується для групування типів медіаряду. Наприклад, символами <i>*/*</i> визначається використання всіх
      типів, а позначення <i>type/*</i> визначає використання всіх підтипів вибраного типу <i>type</i>. Медіатипи
      відокремлюються один від одного комами.<br><br>Кожен медіаряд також характеризується додатковим набором
      параметрів. Одним з них є так званий відносний коефіцієнт переваги <i>q</i>, який приймає значення від 0 до 1,
      відповідно, від менш- до більшнеобхідних типів. Якщо коефіцієнт не вказаний, він дорівнює значенню за
      замовчуванням - 1. Використання кількох параметрів <i>q</i> дозволяє клієнту повідомити серверу відносний ступінь
      переваги для того чи іншого медіатипу.<br><br>В елементі <i>$_SERVER['HTTP_HOST']</i> міститься ім’я сервера, яке
      зазвичай збігається з доменним ім’ям сайту, розташованого на сервері.<br><br>В елементі
      <i>$_SERVER['HTTP_REFERER']</i> міститься адреса, з якої відвідувач прийшов на цю сторінку. Перехід має
      здійснюватися за посиланням.<br><br>Елемент <i>$_SERVER['HTTP_USER_AGENT']</i> містить інформацію про тип та
      версію браузера та операційну систему відвідувача. Наприклад:
      <pre><code>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0 </code></pre>В елементі
      <i>$_SERVER['REMOTE_ADDR']</i> міститься IР-адреса клієнта. При тестуванні на локальній машині ця адреса
      дорівнюватиме 127.0.0.1. Однак при тестуванні в мережі змінна поверне IP-адресу клієнта або останнього
      проксі-сервера, через який клієнт потрапив на сервер.<br><br>В елементі <i>$_SERVER['SCRIPT_FILENAME']</i>
      міститься абсолютний шлях до файлу від кореня диска.<br><br>В елементі <i>$_SERVER['SERVER_NAME']</i> міститься
      ім’я сервера, що зазвичай збігається з доменним ім’ям сайту, розташованого на ньому.<br><br>Крім описаних
      параметрів, суперглобальний масив <i>$_SERVER</i> дозволяє з’ясувати ще ряд параметрів сервера, наприклад порт,
      тип Wеb-сервера, версію НТТР-протоколу, ім’я скрипта, метод і параметри запиту та інші. Для перегляду всіх
      параметрів достатньо вивести їх на екран функцією <a href="https://www.php.net/manual/en/function.print-r"
         target="_blank">Print_r</a>:
      <pre><code>print_r($_SERVER);</code></pre>
   </div>

   <div class="task">
      <br>
      Завдання: <br>
      1) Повторити на практиці Типи суперглобальних масивів , Сесії, Змінні оточення, Масив $_SERVER
      <br>
      <br>
   </div>

</body>

</html>