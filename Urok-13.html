<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Регулярні вирази у PHP</title>
   <link rel="stylesheet" href="assets/css/style.css">
</head>

<body>
   <div class="post-content">
      <h2>Регулярні вирази у PHP</h2>
      Регулярні вирази є дуже сильним інструментом для здійснення маніпуляцій з підрядками в тексті. Однак, вони також є
      дуже складними у вивченні та застосуванні.<br><a data-fancybox="gallery"
         href="assets/img/regulyarni-vurazu-php.jpg">
         <img src="assets/img/regulyarni-vurazu-php.jpg" alt="Регулярні вирази у PHP"
              title="Регулярні вирази у PHP" />
      </a><br>Існує кілька різних діалектів регулярних виразів, серед яких один із найпоширеніших і найрозвиненіших є
      синтаксис <strong>Perl</strong>-сумісних регулярних виразів (<i>PCRE - Perl Compatible Regular
         Expressions</i>).<br><br>Простими словами, регулярний вираз - це шаблон, який застосовується до заданого тексту
      зліва направо. Можна використовувати звичайні символи, які зберігають значення у шаблоні та означають збіг з
      відповідними символами. Наприклад, регулярний вираз, що містить текст "<i>комп</i>", відповідає рядку, який
      містить зазначений підрядок, наприклад "<i>комп'ютер</i>".<br><br>Позначення меж регулярного висловлювання можна
      записати так:
      <pre><code>"/комп/"</code></pre>Прямий слєш (<i>/</i>) спочатку і кінці набору символів служить межею регулярного
      висловлювання, тобто регулярний вираз діятиме доти, доки не зустрінеться другий символ прямого
      слєша.<br><br>Допустимо використовувати інструкції модифікатори шаблону, які діють на весь регулярний вираз.
      Наприклад, модифікатор "<i>i</i>" здійснюватиме пошук за регулярним виразом без урахування регістру. Для
      українських символів у кодуванні <i>UTF8</i> для правильної обробки необхідно додавати модифікатор "<i>u</i>"
      (<i>PCRE_UTF8</i>). Наприклад:
      <pre><code>"/комп/ui"</code></pre>Регулярний вираз із прикладу буде відповідати як рядку "<i>комп'ютер</i>", так і
      "<i>КОМП'ЮТЕР</i>".<br><br>Для прив'язки регулярного висловлювання на початок слова використовується символ
      "<i>^</i>" (<i>caret</i> - знак вставки):
      <pre><code>"/^світ/"</code></pre>Даний вираз буде відповідати рядку "<i>світильник</i>", і не відповідатиме слову
      "<i>всесвіт</i>".<br><br>Знак долара "<i>$</i>" означає кінець рядка:
      <pre><code>"/^світильник$/"</code></pre>Даний регулярний вираз відповідає виключно рядку "<i>світильник</i>", де
      після слова немає іншого тексту.<br><br>Наступний регулярний вираз відповідає порожньому рядку:
      <pre><code>"/^$/"</code></pre>Дуже часто у пошуковому рядку міститься символ початку та кінця регулярного виразу,
      у нашому випадку символ косої риски "<i>/</i>". У цьому випадку необхідно екранувати цей символ за допомогою
      символу зворотного слеша (<i>\</i>):
      <pre><code>"/^світильник\/стельовий$/"</code></pre>У цьому прикладі регулярний вираз буде відповідати рядку
      "<i>світильник/стельовий</i>".<br><br>Як роздільник може виступати будь-який інший символ, наприклад "|":
      <pre><code>"|^світильник\/стельовий$|ui"</code></pre>Змінювати роздільники необхідно виходячи із завдання пошуку,
      наприклад, якщо символ косої риси "<i>/</i>" часто зустрічається в пошуковому рядку, то його можна
      змінити.<br><br>Слід бути дуже уважними, використовуючи деякі символи для роздільників, оскільки вони можуть
      виконувати свою роль у шаблоні. Використання символу вертикальної межі "|" у регулярному вираженні може бути
      використане для завдання альтернативних масок:
      <pre><code>"/^abc|def$/"</code></pre>Даному регулярному виразу відповідає будь-який рядок, що містить підрядки
      "<i>abc</i>" або "<i>def</i>". Вертикальну риску більшості випадків застосовують під час перевірки, наприклад,
      розширень файлів або зон доменних імен.<br><br>Підрядки в регулярних виразах можна групувати за допомогою дужок
      "<i>()</i>":
      <pre><code>"/^колір (червоний|синій|зелений)$/"</code></pre>Цей регулярний вираз буде відповідати рядку виду
      "<i>колір червоний</i>", але замість "<i>червоний</i>" може бути як "<i>синій</i>", так і
      "<i>зелений</i>".<br><br>Для використання дужок як частини пошукового рядка їх слід екранувати. Наприклад,
      відповідати рядку "<i>колір (червоний)</i>" буде такий регулярний вираз:
      <pre><code>"/^колір \(червоний\)$/"</code></pre>Крім угруповання символів, дужки мають ще одне призначення. Всі
      вирази, знайдені у дужках, зберігаються інтерпретатором, і до них можна звернутися під час заміни чи пошуку за
      номером дужки.<br><br>Щоб задати клас символів, необхідно використовувати квадратні дужки "<i>[]</i>". Вони
      обмежують пошук тими символами, які в них є:
      <pre><code>"/[abc]/"</code></pre>Даному регулярному виразу відповідатиме підрядок, який містить хоча б один символ
      з "<i>abc</i>".<br><br>Для створення регулярного виразу, який відповідає всім літерам англійського алфавіту, можна
      перерахувати всі літери в регулярному виразі, а можна записати коротше наступним чином:
      <pre><code>"/[a-z]/i"</code></pre>Будь-які два символи, що поділяються дефісом, задають відповідність діапазону
      символів між ними. У даному регулярному вираженні описані символи нижнього регістру, але модифікатор "<i>i</i>"
      здійснює пошук регістрозалежний.<br><br>Аналогічним чином задаються регулярні вирази, що відповідають цифрам:
      <pre><code>"/[0-9]/"</code></pre>При використанні екранування зворотним слешем деякі символи виконують спеціальну
      інтерпретацію:<br><br><strong>\d</strong> - будь-яка десяткова цифра ([0-9]);<br><br><strong>\D</strong> -
      будь-який символ, крім десяткової цифри;<br><br><strong>\s</strong> - будь-який пробільний символ
      ([\r\n\t\f]);<br><br><strong>\S</strong> - будь-який непробільний символ;<br><br><strong>\w</strong> - будь-який
      символ, що утворює "<i>слово</i>" ([a-zA-Z0-9_]);<br><br><strong>\W</strong> - будь-який символ, що не утворює
      "слово";<br><br><strong>\t</strong> - символ табуляції;<br><br><strong>\n</strong> - символ переводу
      рядка;<br><br><strong>\\</strong> - символ зворотного слешу (\);<br><br><strong>\.</strong> - Символ крапки
      (.).<br><br>Символ крапки "<i>.</i>" позначає будь-який символ у регулярному виразі крім символів розриву рядка
      "<i>\r</i>" або "<i>\n</i>", тому для пошуку крапки слід екранувати цей символ.<br><br>Регулярний вираз для числа
      можна записати так:
      <pre><code>"/[\d]/"</code></pre>Щоб виключити клас символів з пошуку, необхідно в квадратних дужках поставити
      першим символ "<i>^</i>", який діє вже не як покажчик межі рядка, а як заперечення:
      <pre><code>"/[^0-9]/"</code></pre>Цей регулярний вираз відповідає будь-якому символу, що не міститься в діапазоні
      "<i>0-9</i>".<br><br>Список спеціальних символів (метасимволи):
      <pre><code>\^$.[]|()?*+{}</code></pre>Вираз у квадратних дужках часто застосовується разом із так званими
      квантифікаторами, які є символами "<i>?</i>", "<i>+</i>" і "<i>*</i>". Квантифікатори слідують відразу за символом
      і змінюють кількість входжень конкретного символу в рядок:<br><br><strong>?</strong> - символ або входить у рядок
      один раз, або взагалі до неї не входить;<br><br><strong>*</strong> - будь-яке число входжень символу в рядок, у
      тому числі 0;<br><br><strong>+</strong> - одне чи більше число входжень символу рядок.<br><br>Наприклад, якщо
      необхідно знайти підрядок, що містить одну або більше цифр, слід скористатися виразом:
      <pre><code>"/[\d]+/"</code></pre>Символ "<i>*</i>" використовується для будь-якого числа входжень рядка в
      підрядок, тобто регулярний вираз відповідає або порожній рядку, або рядку, що містить необмежену кількість цифр.
      <pre><code>"/^[\d]*$/"</code></pre>У регулярних виразах також застосовуються фігурні дужки (<i>{}</i>), які
      призначені для вказівки числа або діапазону чисел повторення елемента:<br><br>"<i>ab{2}</i>" - відповідає рядку
      "<i>abb</i>";<br><br>"<i>ab{2,}</i>" - відповідає рядку, в якому за "b" слід не менше двох
      "<i>b</i>";<br><br>"<i>ab{2,4}</i>" - відповідає рядку, в якому за "<i>b</i>" слідує від 2 до 4 символів
      "<i>b</i>".<br><br>Вираз "<i>{0,}</i>" повністю аналогічний "<i>*</i>", а "<i>{1,}</i>" - "<i>+</i>". Вираз
      "<i>{0,1}</i>" можна записати коротше, використовуючи "<i>?</i>".<br><br>Для об'єднання символів у послідовність
      їх необхідно помістити в круглі дужки. Наприклад, наступний регулярний вираз відповідає рядку, в якому за
      "<i>a</i>" слідує від 2 до 4 послідовностей "<i>bc</i>";
      <pre><code>"a(bc){2,4}/"</code></pre>Існує модифікатор "<i>U</i>", який інвертує жадібність. Наприклад, вираз
      "<i>&lt;.*&gt;</i>" відповідає рядку, що містить кілька тегів HTML-розмітки, повністю. Щоб виділити окремі теги,
      можна застосувати жадібність: "<i>&lt;.*?&gt;</i>" або "<i>&lt;.*&gt;/U</i>".<br><br>Жадібність квантифікаторів
      може виявитися значною проблемою. Наприклад, часто очікують, що вираз "<i>&lt;.*&gt;</i>" знайде у тексті теги
      HTML. Однак якщо в тексті є більше одного HTML-тега, то цьому виразу цілком відповідає рядок, що містить безліч
      тегів.<h2>Функції для роботи з регулярними виразами</h2>Після прочитання теоретичних основ настав час переходити
      до практичних. Для роботи з регулярними виразами є кілька функцій.<br><br>Першою розглянемо функцію <a
         href="https://www.php.net/manual/en/function.preg-match.php" target="_blank">Preg_match</a>, яка здійснює пошук
      у рядку за регулярним виразом і має наступний синтаксис:
      <pre><code>preg_match(<br>    string $pattern,<br>    string $subject,<br>    array &amp;$matches = null,<br>    int $flags = 0,<br>    int $offset = 0<br>): int|false<br></code></pre>
      Функція <i>Preg_match</i> шукає у заданому тексті <i>Subject</i> збіг із шаблоном <i>Pattern</i>. Якщо заданий
      необов'язковий параметр <i>Matches</i>, результати пошуку поміщаються в масив. Елемент <i>$matches[0]</i>
      міститиме частину рядка, що відповідає входженню всього шаблону, <i>$matches[i]</i> - частину рядка, що відповідає
      першим круглим дужкам, <i>$matches[2]</i> - другим і т.д.<br><br>Необов'язковий параметр <i>Flags</i> може
      приймати єдине значення <i>PREG_OFFSET_CAPTURE</i>, при вказівці якого змінюється формат масиву, що повертається
      <i>$matches</i> - кожне входження повертається у вигляді масиву, в нульовому елементі якого міститься знайдени
      підрядок, а в першому - зміщення. Пошук здійснюється ліворуч, з початку рядка.<br><br>Функція <i>Preg_match</i>
      повертає кількість знайдених відповідностей, яка може приймати лише 2 значення - 0 (збіги не знайдені) та 1,
      оскільки ця функція припиняє свою роботу після першого знайденого збігу.<br><br>Для пошуку всіх збігів слід
      скористатися функцією <a href="https://www.php.net/manual/en/function.preg-match-all"
         target="_blank">Preg_match_all</a>, яка має наступний синтаксис:
      <pre><code>preg_match_all(<br>    string $pattern,<br>    string $subject,<br>    array &amp;$matches = null,<br>    int $flags = 0,<br>    int $offset = 0<br>): int|false</code></pre>
      Функція <i>Preg_match_all</i> шукає у рядку <i>Subject</i> всі збіги з шаблоном <i>Pattern</i> і поміщає результат
      у масив <i>Matches</i> у порядку, що визначається комбінацією прапорів <i>Flags</i>. Так само як і в попередній
      функції можна задати зміщення <i>Offset</i>, починаючи з якого буде здійснюватися пошук в рядку <i>Subject</i>.
      Після знаходження першої відповідності наступні пошуки здійснюватимуться не з початку рядка, а від кінця
      останнього знайденого входження.<br><br>Перейдемо до функції, яка, крім пошуку, здійснює і заміну за регулярним
      виразом — <a href="https://www.php.net/manual/en/function.preg-replace" target="_blank">Preg_replace</a>:
      <pre><code>preg_replace(<br>    string|array $pattern,<br>    string|array $replacement,<br>    string|array $subject,<br>    int $limit = -1,<br>    int &amp;$count = null<br>): string|array|null</code></pre>
      Функція <i>Preg_replace</i> виконує пошук збігів у рядку <i>Subject</i> із шаблоном <i>Pattern</i> та замінює їх
      на <i>Replacement</i>.<br><br>Функція <a href="https://www.php.net/manual/en/function.preg-split"
         target="_blank">Preg_split</a> розбиває рядок за регулярним виразом.
      <pre><code>preg_split(<br>    string $pattern,<br>    string $subject,<br>    int $limit = -1,<br>    int $flags = 0<br>): array|false</code></pre>
      Функція повертає масив, що складається з підрядків заданого рядка <i>Subject</i>, який розбитий за межами, що
      відповідають шаблону <i>Pattern</i>.<br><br>У більшості випадків використання вище описаних функцій цілком
      достатньо для вирішення багатьох завдань.<br><br>Також існують додаткові конструкції шаблонів:<br><br><i>(?<a
            href="/hashtag/Коментар">#Коментар</a>) </i> - коментар у тілі шаблону. Іноді дуже корисно розмістити у тілі
      регулярного вираження конкретний коментар для кращого розуміння роботи.<br><br>(?: Шаблон) - угруповання як і
      "()", але без зворотного посилання. Це угруповання дуже корисне для завдання шаблону, але без створення зворотного
      посилання.<br><br>(?=шаблон) - "заглядання" вперед. Ця конструкція може знадобитися для пошуку за шаблоном з
      наперед вказаним виразом, наприклад, вираз "<i>/\w+(?=\t)/</i>" відповідає слову, за яким йде символ табуляції,
      але символ "<i>\t</i>" не включається до результату.<br><br>А тепер опишемо найчастіше вживані приклади
      використання регулярних виразів:<br><br>Перевірка правильності введення електронної пошти E-mail:
      <pre><code>preg_match("/^[a-z0-9_\-\.]+@[a-z0-9_^\.]+\.[a-z]{1,6}$/ui", $email)</code></pre>До символу собачки
      шаблон шукає букви та цифри, знак тире, нижнього підкреслення та крапки одне або більше число входжень починаючи з
      початку рядка:
      <pre><code>^[a-z0-9_\-\.]+</code></pre>Далі йде друга частина поштової адреси, починаючи з собачки, маючи той же
      набір символів, що і перша частина:
      <pre><code>@[a-z0-9_^\.]+</code></pre>Після цього перевіряємо доменну зону, яка складається виключно з рядка букв
      певної кількості символів до кінця рядка:
      <pre><code>\.[a-z]{1,6}$</code></pre>Також за допомогою регулярного виразу ми можемо вибрати всі E-mail з тексту:
      <pre><code>$text = 'Тут текст та поштова адреса test@gmail.com і ще одна адреса admin@i.ua';<br>preg_match_all("/[a-z0-9_\-\.]+@[a-z0-9_^\.]+\.[a-z]{1,6}/ui", $text, $matches, PREG_PATTERN_ORDER);<br>foreach ($matches[0] as $key =&gt; $val) {<br>    $email = filter_var($val, FILTER_VALIDATE_EMAIL);<br>    if ($email) $output[] = $email;<br>}</code></pre>
      На відміну від перевірки правильності введення E-mail, при вибірці ми прибрали в шаблоні символ початку (<i>^</i>)
      і кінця (<i>$</i>) рядка. Результат цього прикладу:
      <pre><code>Array<br>(<br>    [0] =&gt; test@gmail.com<br>    [1] =&gt; admin@i.ua<br>)</code></pre>Перевірка
      правильності введення імені:
      <pre><code>preg_match('#^[а-яґїієa-z\-\_\'.\d\s]+$<a href="/hashtag/ui">#ui</a>', $name);</code></pre>Перевірка
      правильності введення числа:
      <pre><code>preg_match('/([0-9]+)/ui', $id)</code></pre>Коректність введення дати:
      <pre><code>$date = "2017.05.25";<br>preg_match('/^[0-9]{4}.[0-9]{2}.[0-9]{2}$/ui', $date);</code></pre>Коректність
      введення часу:
      <pre><code>preg_match("/^[0-9]{2}+:[0-9]{2}+:[0-9]{2}$/ui", $time))</code></pre>Видалити всі визначення стилів
      <i>Style</i>:
      <pre><code>preg_replace('/style=\"[^\"]*\"/', '', $string);</code></pre>Оскільки стилі можуть знаходитися
      всередині практично будь-якого тега, у прикладі видаляється виключно визначення стилю без тега.<br><br>Видалити
      всі визначення малих елементів документа <i>Span</i>:
      <pre><code>preg_replace('#&lt;span[^&gt;]*?&gt;<a href="/hashtag/is">#is</a>', '', $string);<br>preg_replace('#&lt;\/span&gt;<a href="/hashtag/is">#is</a>', '', $table);</code></pre>
      Так само можна видалити будь-який тег, наприклад, для заголовка H1:
      <pre><code>preg_replace('#&lt;h1[^&gt;]*?&gt;<a href="/hashtag/is">#is</a>', '', $table);<br>preg_replace('#&lt;\/h1&gt;<a href="/hashtag/is">#is</a>', '', $table);</code></pre>
      Очищення таблиць за допомогою регулярних виразів PHP можна зробити так:
      <pre><code>// Видаляємо всі атрибути Table:<br>$table = preg_replace('#&lt;table.*&gt;<a href="/hashtag/siU">#siU</a>', '&lt;table&gt;', $table););<br>// Видаляємо всі атрибути TR:<br>$table = preg_replace('#&lt;tr.*&gt;<a href="/hashtag/siU">#siU</a>', '&lt;tr&gt;', $table);<br>// Видаляємо всі атрибути TD (крім colspan або rowspan):<br>$table = preg_replace('#&lt;td[^&gt;]+((colspan|rowspan)=[^\s&gt;]+?)(|.*)&gt;<a href="/hashtag/siU">#siU</a>', '&lt;td \\1&gt;', $ table);</code></pre>
      Перевірити правильність імені файлу можна за допомогою наступного регулярного виразу:
      <pre><code>preg_match("/(^[a-zA-Z0-9]+([a-zA-Z\_0-9\.-]*))$/", $filename)</code></pre>Вирізати всі зображення у
      тексті:
      <pre><code>preg_replace("/&lt;img (.*?)&gt;/", '', $content)</code></pre>Знайти усі посилання:
      <pre><code>preg_match_all('#&lt;a [^&gt;]*href="(.*)"[^&gt;]*&gt;<a href="/hashtag/Ui">#Ui</a>', $content , $url);</code></pre>
      Уявіть ситуацію, коли користувач не використовує символ пропуску після крапки або коми. В даному випадку виходить
      дуже велике слово, яке не завжди може поміститися в поле, що провокує горизонтальну прокрутку. Щоб цього не
      сталося, можна скористатися наступним регулярним виразом, який після крапки або коми додаватиме символ пробілу:
      <pre><code>preg_replace('/(\.|\,)([^\s])/ui', '$1 $2', $content)</code></pre>Знайти всі хештеги (<a
         href="/hashtag/tag">#tag</a>) можна так:
      <pre><code>preg_match_all("/\#(\w+[^\s]*)/ui", $text, $matches, PREG_PATTERN_ORDER);</code></pre>Або вручну додати
      необхідні символи та їх кількість, дозволені для складання хештегов:
      <pre><code>preg_match_all("/\#([a-zа-яґїіє0-9\-\_]{1,50})/ui", $text, $matches, PREG_PATTERN_ORDER);</code></pre>
      Якщо необхідно додати до src зображення назву домену (при парсингу сторінки, на якій шлях src вказаний відносний,
      а потрібно зробити повний):
      <pre><code>preg_replace('/src="(http:\/\/[^\/"]+\/?)?([^"]*)"/', "src=\"http://mysite.com/\\2\"", $text);</code></pre>
      Якщо час у базі даних зберигіється у форматі «12:00:00», а потрібно вивести у «12:00», можна виконати так:
      <pre><code>preg_replace("#(:\d+):\d+#", '$1', $row['time'])</code></pre>Перевірити введений час

      <br>
      <br>
      <textarea style="height: 70vh">
      <pre><code>"|^світильник\/стельовий$|ui"</code></pre>

      UI в регулярному виразі стоїть для практичності використання в кількох сценаріях:<br>

      U включає "нежадний" режим, в якому символ * або + зупиняються на першому збігу, а не на останньому. Це корисно,
      коли ви хочете знайти текст в квадратних дужках, наприклад, в [tag]текст[/tag].<br>
      I зробить вираз нечутливим до регістру символів, тобто він буде збігатися зі словом "Світильник" або
      "світильник".<br>
      У цьому прикладі "|^світильник/стельовий$|ui" UI використовується для того, щоб зробити регулярний вираз чутливим
      до регістру символів і використовувати "нежадний" режим. Він шукає рядок, який точно містить
      "світильник/стельовий", незалежно від того, який регістр використовується.<br>

      =====<br><br>

      Символ решітки (#) в даному preg_match('#^[а-яґїієa-z\-\_\'.\d\s]+$#ui', $name); випадку використовується для
      обгортання регулярного виразу замість стандартного символу слеша (/). Це дозволяє уникнути екранування символу
      слеша в регулярному виразі, що може стати проблемою, якщо регулярний вираз вже містить багато символів
      слеша.<br><br>

      У даному випадку регулярний вираз "#^[а-яґїієa-z-_'.\d\s]+$#ui" перевіряє, чи міститься у змінній $name лише
      літери кирилиці та латиниці, деякі додаткові символи (-, _, ', .), цифри та пробіли. У виразі також
      використовуються два модифікатори регулярного виразу: "u" для підтримки кодування UTF-8 та "i" для ігнорування
      регістру.<br><br>

      Отже символ решітки (#) в даному випадку використовується замість стандартного символу слеша (/) як обгортка для
      регулярного виразу, що дозволяє уникнути екранування символу слеша в регулярному виразі, і зробити регулярний
      вираз більш читабельним.<br><br>

      =======<br><br>

      Символи #is в регулярних виразах, які використовуються у функції preg_replace(), є модифікаторами регулярного
      виразу.<br><br>

      Модифікатор i вказує, що регулярний вираз повинен бути нечутливим до регістру символів. Це означає, що при
      порівнянні символів будуть враховуватися тільки їхні графічні властивості, а не регістр. У випадку з функцією
      preg_replace(), вона буде здійснювати заміну тексту, ігноруючи регістр символів.<br><br>

      Модифікатор s включає "однаковий з символом . режим" (dotall mode), в якому символ . буде збігатися з будь-яким
      символом, включаючи символ переносу рядка (\n). Це означає, що якщо рядок містить спеціальні символи, такі як
      переноси рядка, то регулярний вираз буде збігатися з усім текстом, включаючи спеціальні символи.<br><br>

      У виразах preg_replace('#<span[^>]*?>#is', '', $string) та preg_replace('#<\ /span>#is', '', $table) символи #is
      використовуються як модифікатори, які вказують, що відповідні регулярні вирази повинні виконуватися в
      нечутливому до регістру режимі та режимі dotall.<br><br>

      =====<br><br>

      <pre><code>
      // Видаляємо всі атрибути Table:
      $table = preg_replace('#<table.*>#siU', '<table>', $table););
      // Видаляємо всі атрибути TR:
      $table = preg_replace('#<tr.*>#siU', '<tr>', $table);
      // Видаляємо всі атрибути TD (крім colspan або rowspan):
      $table = preg_replace('#<td[^>]+((colspan|rowspan)=[^\s>]+?)(|.*)>#siU', '<td \\1>', $ table);
      </code></pre>

      У вказаному коді використовується рядок #siU для виконання операцій по заміні тексту в рядках, які містять
      HTML-код.<br><br>

      У рядках коду, що містять preg_replace, символ # використовується як роздільник для обмеження регулярного
      виразу. Символи i, s і U використовуються як модифікатори регулярних виразів:<br><br>

      Модифікатор "i" означає, що регулярний вираз ігнорує регістр символів. Тобто, наприклад, символи 'A' і 'a'
      будуть вважатися однаковими.<br>
      Модифікатор "s" ввімкнутий для вважає кінець рядка символом нового рядка, що дозволяє включати його в
      регулярний вираз.<br>
      Модифікатор "U" використовується для вказання, що відповідність до першої знайденої підстроки повинна бути
      найменшою.<br>
      Також, вказаний рядок застосовується для заміни атрибутів в таблицях HTML. Він видаляє всі атрибути таблиці,
      рядків і стовпців, крім атрибутів colspan і rowspan. В результаті в таблицях залишаються лише теги <table>,
         <tr> та <td>, що може бути корисно при обробці HTML-даних.<br>

      ========<br><br>


      #Ui preg_match_all('#<a [^>]*href="(.*)"[^>]*>#Ui', $content , $url);<br>

         У даному випадку рядок #Ui використовується як модифікатор регулярного виразу в функції
         preg_match_all, що використовується для виявлення посилань у HTML-коді.<br><br>

         Конкретні модифікатори регулярних виразів, використані в даному випадку, мають наступне
         значення:<br>

         Модифікатор "U" вказує на "ungreedy" (нежадний) режим співставлення з регулярним виразом. Це
         означає, що пошук буде проводитись з мінімальною кількістю символів.<br>
         Модифікатор "i" вимикає режим розрізнення між великими і малими літерами.<br>
         Модифікатор "U" відключає зіставлення шаблонів з регулярним виразом в "greedy" (жадібному)
         режимі.<br>
         Загальне призначення регулярного виразу - знайти всі теги <a> у HTML-коді, які мають атрибут
            href. Результати зберігаються в масиві $url. Відповідно, функція preg_match_all може бути
            використана для обробки HTML-коду і знаходження в ньому певних частин, що мають певний
            формат, наприклад, посилань на інші веб-сторінки.<br>
      </textarea>
   </div>


   <div class="task">
      <br>
      Завдання:<br>
      1) Пройти вивчений матеріал<br>
      2) використати регулярні вирази<br>
      3) на практиці використати функції для роботи з регулярними виразами<br>
      <br>
      <br>
   </div>

</body>

</html>